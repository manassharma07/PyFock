window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyfock", "modulename": "pyfock", "kind": "module", "doc": "<p><!-- PROJECT SHIELDS -->\n<!--\n<strong>* I'm using markdown \"reference style\" links for readability.\n<em></strong> Reference links are enclosed in brackets [ ] instead of parentheses ( ).\n<strong></em> See the bottom of this document for the declaration of the reference variables\n<em></strong> for contributors-url, forks-url, etc. This is an optional, concise syntax you may use.\n*</em>* <a href=\"https://www.markdownguide.org/basic-syntax/#reference-style-links\">https://www.markdownguide.org/basic-syntax/#reference-style-links</a>\n-->\n<a href=\"https://github.com/manassharma07/PyFock/contributors\"><img src=\"https://img.shields.io/github/contributors/manassharma07/crysx_nn.svg?style=for-the-badge\" alt=\"Contributors\" /></a>\n<a href=\"https://github.com/manassharma07/PyFock/network/members\"><img src=\"https://img.shields.io/github/forks/manassharma07/PyFock.svg?style=for-the-badge\" alt=\"Forks\" /></a>\n<a href=\"https://github.com/manassharma07/PyFock/stargazers\"><img src=\"https://img.shields.io/github/stars/manassharma07/PyFock.svg?style=for-the-badge\" alt=\"Stargazers\" /></a>\n<a href=\"https://github.com/manassharma07/PyFock/issues\"><img src=\"https://img.shields.io/github/issues/manassharma07/PyFock.svg?style=for-the-badge\" alt=\"Issues\" /></a>\n<a href=\"https://github.com/manassharma07/PyFock/blob/main/LICENSE\"><img src=\"https://img.shields.io/github/license/manassharma07/PyFock.svg?style=for-the-badge\" alt=\"MIT License\" /></a>\n<a href=\"https://www.linkedin.com/in/manassharma07\"><img src=\"https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&amp;logo=linkedin&amp;colorB=555\" alt=\"LinkedIn\" /></a>\n<a href=\"https://github.com/manassharma07/PyFock/blob/main/Documentation.md\"><img src=\"https://img.shields.io/badge/-docs-blue.svg?style=for-the-badge&amp;logo=documentation&amp;colorB=389\" alt=\"Documentation\" /></a></p>\n\n<p><!-- PROJECT LOGO -->\n<br /></p>\n\n<div align=\"center\">\n  <!-- <a href=\"https://github.com/manassharma07/pyfock\">\n    <img src=\"https://github.com/manassharma07/PyFock/blob/main/logo_crysx_pyfock.png\" alt=\"Logo\" width=\"320\" height=\"200\">\n  </a> -->\n\n<h3 align=\"center\">PyFock</h3>\n\n  <p align=\"center\">\n    An efficient and parallelizable pure Python electronic structure theory code with GPU acceleration, made possible via just-in-time compilation functionalities of Numba.\n    <br />\n    <a href=\"https://github.com/manassharma07/pyfock/blob/main/Documentation.md\"><strong>Explore the docs \u00bb</strong></a>\n    <br />\n    <br />\n    <a href=\"https://github.com/manassharma07/pyfock/blob/main/examples/ex13.ipynb\">View Demo</a>\n    \u00b7\n    <a href=\"https://github.com/manassharma07/pyfock/issues\">Report Bug</a>\n    \u00b7\n    <a href=\"https://github.com/manassharma07/pyfock/issues\">Request Feature</a>\n  </p>\n</div>\n\n<p><!-- TABLE OF CONTENTS -->\n<details>\n  <summary>Table of Contents</summary></p>\n\n<p><ol>\n  <li>\n    <a href=\"#about-the-project\">About The Project</a>\n    <ul>\n      <li><a href=\"#built-with\">Built With</a></li>\n    </ul>\n  </li>\n  <li>\n    <a href=\"#getting-started\">Getting Started</a>\n    <ul>\n      <li><a href=\"#prerequisites\">Prerequisites</a></li>\n      <li><a href=\"#installation\">Installation</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#usage\">Usage</a></li>\n  <li><a href=\"#features\">Features</a></li>\n  <li><a href=\"#roadmap\">Roadmap</a></li>\n  <li><a href=\"#contributing\">Contributing</a></li>\n  <li><a href=\"#license\">License</a></li>\n  <li><a href=\"#contact\">Contact</a></li>\n  <li><a href=\"#acknowledgments\">Acknowledgments</a></li>\n  <li><a href=\"#citation\">Citation</a></li>\n</ol></p>\n\n<p></details></p>\n\n<p><!-- ABOUT THE PROJECT --></p>\n\n<h2 id=\"about-the-project\">About The Project</h2>\n\n<p><a href=\"https://github.com/manassharma07/pyfock\"><img src=\"https://github.com/manassharma07/PyFock/blob/main/logo_crysx_pyfock.png\" alt=\"Product Name Screen Shot\" /></a></p>\n\n<p>PyFock is a quantum chemistry package that enables efficient density functional theory (DFT) and related calculations for molecular systems, all using the Python programming language. By utilizing Numba's just-in-time (JIT) compilation, PyFock is able to achieve efficient and parallelizable performance for all the compute-intensive portions of the calculations. Furthermore, PyFock can utilize multiple GPUs to accelerate some of the expensive calculations. This makes PyFock a highly flexible and powerful tool for quantum chemistry simulations, all within a single, easy-to-use package.</p>\n\n<p>Some advantages of this approach include the ability to easily incorporate PyFock into existing Python workflows, the accessibility and versatility of the Python language, and the ability to take advantage of the numerous scientific and numerical libraries available in the Python ecosystem.</p>\n\n<ul>\n<li>Yes, the code is written completely in Python (even the computationally intensive molecular integrals).</li>\n<li>Yet, the code is as efficient as PySCF/Psi4 (sometimes even more efficient), because the computationally intensive portions are accelerated via Numba, NumPy, NumExpr, Scipy, Opt_Einsum, Joblib, CuPy, Numba-CUDA, etc.</li>\n<li>The code employs Gaussian-type Orbitals (GTOs) as basis functions.</li>\n<li>The calculation of the electron repulsion integrals (ERI) is accelerated via the density fitting method (along with Schwarz screening), resulting in quadratic scaling with respect to the no. of basis functions (Nbf), similar to that of PySCF.</li>\n<li>The evaluation of the exchange-correlation term is done in batches/blocks and scales approximately linearly with system size as only a fixed amount of basis functions contribute to a given batch which is mostly the same for all batches. Furthermore, the XC term evaluation can be accelerated via multiple GPUs using the CuPy and Numba libraries. (Preliminary tests indicate that an Nvidia RTX 2070 can do the XC evaluations 2X faster than 4 CPU cores and more than 8X faster on a P100.) </li>\n<li>Almost all the computationally intensive portions are parallelized via Numba's prange or Joblib (multithreading).</li>\n<li>KS matrix diagonalization and DIIS can also be accelerated using GPUs.</li>\n</ul>\n\n<h3 id=\"license-and-third-party-code-acknowledgments\">License and Third-Party Code Acknowledgments:</h3>\n\n<ul>\n<li>For ERIs using Rys quadrature (roots 1\u20135), the code was adapted from <a href=\"https://github.com/rpmuller/MolecularIntegrals.jl\">MolecularIntegrals.jl</a> (MIT License).</li>\n<li>Some support for molecular integrals, specifically Rys quadrature roots 6\u201310, was obtained from <a href=\"https://github.com/sunqm/libcint\">PySCF's libcint</a> (Apache v2 License).</li>\n<li>The DIIS-based SCF convergence routine was adapted from <a href=\"https://github.com/jjgoings/McMurchie-Davidson\">McMurchie-Davidson</a> (BSD 3-Clause License).</li>\n<li>There are also some functions where I have tried to utilize many more of the <a href=\"https://github.com/jjgoings/McMurchie-Davidson\">McMurchie-Davidson</a>'s code for molecular integrals with JIT compilation, but have been unsuccessful due to their use of recurrence (which is incompatible with Numba). \nOnly the dipole matrix appears to be usable at the moment. But I nonetheless, acknowledge that any integral using the MMD scheme comes from Joshua Going's library with BSD 3-Clause License.</li>\n<li>For the Boys Function evaluation, the code was adapted from <a href=\"https://github.com/peter-reinholdt/pyboys\">PyBoys</a> with BSD 3-Clause License. </li>\n<li>The PyFock's implementation of exchange-correlation functionals is mainly taken from <a href=\"https://github.com/wangenau/eminus\">eminus</a> code with Apache v2 License.</li>\n</ul>\n\n<p><!-- MARKDOWN LINKS &amp; IMAGES -->\n<!-- <a href=\"https://www.markdownguide.org/basic-syntax/#reference-style-links\">https://www.markdownguide.org/basic-syntax/#reference-style-links</a> -->\nModules:</p>\n\n<ul>\n<li><code>Mol</code>: Molecular properties</li>\n<li><code>Basis</code>: Basis set management</li>\n<li><code>Integrals</code>: 1e/2e integral routines</li>\n<li><code>XC</code>, <code>Grids</code>: Exchange-correlation and grid definitions</li>\n<li><code>Utils</code>, <code>Graphics</code>: Helper utilities and visualization</li>\n</ul>\n\n<p>This project benefits from the Python scientific stack: NumPy, SciPy, Opt_Einsum, NumExpr, Joblib, and more.  </p>\n\n<p>Repository: <a href=\"https://github.com/manassharma07/PyFock\">https://github.com/manassharma07/PyFock</a><br />\nLicense: MIT<br />\nAuthor: Manas Sharma  </p>\n\n<p>For usage examples, demos, and API documentation, refer to the online documentation or example notebooks.</p>\n"}, {"fullname": "pyfock.Basis", "modulename": "pyfock.Basis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Basis.Basis", "modulename": "pyfock.Basis", "qualname": "Basis", "kind": "class", "doc": "<p>Class to store and manage basis function properties for a given molecular system.</p>\n\n<p>This class processes atomic basis set information for each atom in the molecule,\nincluding primitive Gaussian functions, shells, and contracted basis functions (AOs).\nIt also supports TURBOMOLE-style shell ordering.</p>\n"}, {"fullname": "pyfock.Basis.Basis.__init__", "modulename": "pyfock.Basis", "qualname": "Basis.__init__", "kind": "function", "doc": "<p>Initialize a Basis object for storing basis function properties.</p>\n\n<p>Args:<br />\n    mol: Mol object containing molecular information<br />\n    basis: Dictionary specifying the basis set to be used for each atom, or None to use mol.basis<br />\n    tmoleFormat (bool): Whether to use TURBOMOLE format ordering for basis functions  </p>\n\n<p>Returns:\n    None</p>\n\n<p>Raises:\n    None - prints error message if mol is None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">tmoleFormat</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "pyfock.Basis.Basis.basisSet", "modulename": "pyfock.Basis", "qualname": "Basis.basisSet", "kind": "variable", "doc": "<p>Basis set name or label.\nType: str</p>\n"}, {"fullname": "pyfock.Basis.Basis.nao", "modulename": "pyfock.Basis", "qualname": "Basis.nao", "kind": "variable", "doc": "<p>Number of basis functions (atomic orbitals).\nType: int</p>\n"}, {"fullname": "pyfock.Basis.Basis.nshells", "modulename": "pyfock.Basis", "qualname": "Basis.nshells", "kind": "variable", "doc": "<p>Number of shells.\nType: int</p>\n"}, {"fullname": "pyfock.Basis.Basis.totalnprims", "modulename": "pyfock.Basis", "qualname": "Basis.totalnprims", "kind": "variable", "doc": "<p>Total number of primitive Gaussian functions.\nType: int</p>\n"}, {"fullname": "pyfock.Basis.Basis.nprims", "modulename": "pyfock.Basis", "qualname": "Basis.nprims", "kind": "variable", "doc": "<p>Number of primitives in each shell.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_coeffs", "modulename": "pyfock.Basis", "qualname": "Basis.prim_coeffs", "kind": "variable", "doc": "<p>Primitive contraction coefficients.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_expnts", "modulename": "pyfock.Basis", "qualname": "Basis.prim_expnts", "kind": "variable", "doc": "<p>Exponents of primitives.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_coords", "modulename": "pyfock.Basis", "qualname": "Basis.prim_coords", "kind": "variable", "doc": "<p>Coordinates of each primitive function.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_norms", "modulename": "pyfock.Basis", "qualname": "Basis.prim_norms", "kind": "variable", "doc": "<p>Normalization constants of primitives.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_atoms", "modulename": "pyfock.Basis", "qualname": "Basis.prim_atoms", "kind": "variable", "doc": "<p>Atom index corresponding to each primitive.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.nprims_atoms", "modulename": "pyfock.Basis", "qualname": "Basis.nprims_atoms", "kind": "variable", "doc": "<p>Number of primitives per atom as (atom_index, nprims).\nType: List[Tuple[int, int]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.prim_shells", "modulename": "pyfock.Basis", "qualname": "Basis.prim_shells", "kind": "variable", "doc": "<p>Shell index corresponding to each primitive.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.nprims_shells", "modulename": "pyfock.Basis", "qualname": "Basis.nprims_shells", "kind": "variable", "doc": "<p>Number of primitives per shell as (shell_index, nprims).\nType: List[Tuple[int, int]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.nprims_shell_l_list", "modulename": "pyfock.Basis", "qualname": "Basis.nprims_shell_l_list", "kind": "variable", "doc": "<p>Angular momentum and primitive count per shell as (l, nprims).\nType: List[Tuple[int, int]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.alpha_max", "modulename": "pyfock.Basis", "qualname": "Basis.alpha_max", "kind": "variable", "doc": "<p>Maximum exponent among primitives for each atom.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.alpha_min", "modulename": "pyfock.Basis", "qualname": "Basis.alpha_min", "kind": "variable", "doc": "<p>Minimum exponent of primitives per shell for each atom.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.ncontrs", "modulename": "pyfock.Basis", "qualname": "Basis.ncontrs", "kind": "variable", "doc": "<p>Total number of contracted basis functions.\nType: int</p>\n"}, {"fullname": "pyfock.Basis.Basis.contrs_norm", "modulename": "pyfock.Basis", "qualname": "Basis.contrs_norm", "kind": "variable", "doc": "<p>Normalization factors for contracted basis functions.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.shell_degen", "modulename": "pyfock.Basis", "qualname": "Basis.shell_degen", "kind": "variable", "doc": "<p>Degeneracy of each shell.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.shellsLabel", "modulename": "pyfock.Basis", "qualname": "Basis.shellsLabel", "kind": "variable", "doc": "<p>Label of each shell (e.g., 'S', 'P', etc.).\nType: List[str]</p>\n"}, {"fullname": "pyfock.Basis.Basis.shells", "modulename": "pyfock.Basis", "qualname": "Basis.shells", "kind": "variable", "doc": "<p>Shell index (0: s, 1: p, 2:d).\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.shell_coords", "modulename": "pyfock.Basis", "qualname": "Basis.shell_coords", "kind": "variable", "doc": "<p>Coordinates of each shell center.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_coords", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_coords", "kind": "variable", "doc": "<p>Coordinates of basis functions (same as their parent shell).\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_nprim", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_nprim", "kind": "variable", "doc": "<p>Number of primitives corresponding to each basis function.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_radius_cutoff", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_radius_cutoff", "kind": "variable", "doc": "<p>Radius cutoff for each basis function to speed up AO evaluation.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_expnts", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_expnts", "kind": "variable", "doc": "<p>Primitive exponents used in each basis function.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_coeffs", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_coeffs", "kind": "variable", "doc": "<p>Primitive coefficients for each basis function.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_prim_norms", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_prim_norms", "kind": "variable", "doc": "<p>Primitive normalization constants per basis function.\nType: List[List[float]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_contr_prim_norms", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_contr_prim_norms", "kind": "variable", "doc": "<p>Normalization for the contraction of primitives forming a BF.\nType: List[float]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_lmn", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_lmn", "kind": "variable", "doc": "<p>Cartesian angular momentum indices (l, m, n) per basis function.\nType: List[Tuple[int, int, int]]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_lm", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_lm", "kind": "variable", "doc": "<p>Angular momentum <code>l</code> for each basis function.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_label", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_label", "kind": "variable", "doc": "<p>Label for each basis function.\nType: List[str]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_nbfshell", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_nbfshell", "kind": "variable", "doc": "<p>Number of BFs in the shell of each basis function.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_shell_index", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_shell_index", "kind": "variable", "doc": "<p>Shell index for each basis function.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.shell_bfs_offset", "modulename": "pyfock.Basis", "qualname": "Basis.shell_bfs_offset", "kind": "variable", "doc": "<p>Offset index of the first basis function in each shell.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_nao", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_nao", "kind": "variable", "doc": "<p>Index of each basis function (redundant with <code>nao</code>).\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.bfs_atoms", "modulename": "pyfock.Basis", "qualname": "Basis.bfs_atoms", "kind": "variable", "doc": "<p>Atom index corresponding to each basis function.\nType: List[int]</p>\n"}, {"fullname": "pyfock.Basis.Basis.success", "modulename": "pyfock.Basis", "qualname": "Basis.success", "kind": "variable", "doc": "<p>Indicates if basis parsing was successful.\nType: bool</p>\n"}, {"fullname": "pyfock.Basis.Basis.normalizationFactor", "modulename": "pyfock.Basis", "qualname": "Basis.normalizationFactor", "kind": "function", "doc": "<p>Calculate the normalization factor for a primitive Gaussian function.</p>\n\n<p>Args:\n    alpha (float): Exponent of the Gaussian primitive\n    l (int): Angular momentum quantum number in x-direction\n    m (int): Angular momentum quantum number in y-direction<br />\n    n (int): Angular momentum quantum number in z-direction</p>\n\n<p>Returns:\n    float: Normalization factor for the primitive Gaussian</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">alpha</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.normalizationFactorContraction", "modulename": "pyfock.Basis", "qualname": "Basis.normalizationFactorContraction", "kind": "function", "doc": "<p>Calculate the normalization factor for a contraction of Gaussian primitives.</p>\n\n<p>Args:\n    alphas (list): List of exponents for the primitive Gaussians\n    coeffs (list): List of contraction coefficients\n    norms (list): List of normalization factors for individual primitives\n    l (int): Angular momentum quantum number in x-direction\n    m (int): Angular momentum quantum number in y-direction\n    n (int): Angular momentum quantum number in z-direction\n    lm (int): Total angular momentum (l+m+n)</p>\n\n<p>Returns:\n    float: Normalization factor for the contracted Gaussian</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">alphas</span>, </span><span class=\"param\"><span class=\"n\">coeffs</span>, </span><span class=\"param\"><span class=\"n\">norms</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">lm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.readBasisSetFromFile", "modulename": "pyfock.Basis", "qualname": "Basis.readBasisSetFromFile", "kind": "function", "doc": "<p>Read the basis set block corresponding to a particular atom from a TURBOMOLE format file.</p>\n\n<p>Args:\n    key (str): Atomic species symbol to search for\n    filename (str): Path to the basis set file</p>\n\n<p>Returns:\n    str or bool: Basis set string for the atom, or False if not found</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.load", "modulename": "pyfock.Basis", "qualname": "Basis.load", "kind": "function", "doc": "<p>Load the complete basis set as a string for a given atom/molecule from the CrysX library.</p>\n\n<p>Args:\n    atom (str, optional): Atomic species symbol\n    mol (Mol, optional): Mol object containing molecular information\n    basis_name (str, optional): Name of the basis set to load</p>\n\n<p>Returns:\n    str: Complete basis set string in TURBOMOLE format</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">atom</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">basis_name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.loadfromfile", "modulename": "pyfock.Basis", "qualname": "Basis.loadfromfile", "kind": "function", "doc": "<p>Load the complete basis set as a string for a given atom/molecule from a user-specified file.</p>\n\n<p>Args:\n    atom (str, optional): Atomic species symbol\n    mol (Mol, optional): Mol object containing molecular information<br />\n    basis_name (str, optional): Path to the basis set file</p>\n\n<p>Returns:\n    str: Complete basis set string in TURBOMOLE format</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">atom</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">basis_name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.createCompleteBasisSet", "modulename": "pyfock.Basis", "qualname": "Basis.createCompleteBasisSet", "kind": "function", "doc": "<p>Create the complete basis set string for a given molecule using the basis dictionary.</p>\n\n<p>Args:\n    mol: Mol object containing molecular information\n    basis (dict): Dictionary mapping atom types to basis set strings</p>\n\n<p>Returns:\n    str: Complete basis set string for all atoms in the molecule</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">basis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.cart2sph", "modulename": "pyfock.Basis", "qualname": "Basis.cart2sph", "kind": "function", "doc": "<p>Get the transformation matrix from Cartesian to real spherical harmonics for a given angular momentum.</p>\n\n<p>Args:\n    l (int): Angular momentum quantum number\n    ordering (str): Ordering convention ('pyscf' or other)</p>\n\n<p>Returns:\n    numpy.ndarray: Transformation matrix from Cartesian to spherical basis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">ordering</span><span class=\"o\">=</span><span class=\"s1\">&#39;pyscf&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.cart2sph_basis", "modulename": "pyfock.Basis", "qualname": "Basis.cart2sph_basis", "kind": "function", "doc": "<p>Return the complete Cartesian to spherical harmonic basis transformation matrix for all shells.</p>\n\n<p>Returns:\n    matrix: Block diagonal transformation matrix for the entire basis set</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.sph2cart_basis", "modulename": "pyfock.Basis", "qualname": "Basis.sph2cart_basis", "kind": "function", "doc": "<p>Return the complete spherical to Cartesian basis transformation matrix for all shells.</p>\n\n<p>Returns:\n    matrix: Block diagonal transformation matrix (pseudoinverse of cart2sph)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.readBasisFunctionInfo", "modulename": "pyfock.Basis", "qualname": "Basis.readBasisFunctionInfo", "kind": "function", "doc": "<p>Read and parse the basis set information to populate basis function properties.</p>\n\n<p>Args:\n    mol: Mol object containing molecular information\n    basisSet (str): Complete basis set string in TURBOMOLE format</p>\n\n<p>Returns:\n    None - populates internal data structures with basis function information</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">basisSet</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Basis.Basis.calc_nprim_for_each_angular_momentum_l", "modulename": "pyfock.Basis", "qualname": "Basis.calc_nprim_for_each_angular_momentum_l", "kind": "function", "doc": "<p>Calculate the number of primitives for each angular momentum quantum number.</p>\n\n<p>Args:\n    tuple_list (list): List of tuples containing (angular_momentum, num_primitives)</p>\n\n<p>Returns:\n    list: List of tuples with summed primitives for each unique angular momentum</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tuple_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT", "modulename": "pyfock.DFT", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT", "modulename": "pyfock.DFT", "qualname": "DFT", "kind": "class", "doc": "<p>A class for performing Density Functional Theory (DFT) calculations \nwith optional support for density fitting (DF), GPU acceleration, and LibXC.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule\n    Molecular object on which the DFT calculation is to be performed.</p>\n\n<p>basis : Basis\n    Orbital basis set used for the SCF calculation.</p>\n\n<p>auxbasis : Basis, optional\n    Auxiliary basis set for density fitting (DF). If None, a default will be assigned.</p>\n\n<p>conv_crit : float, optional\n    Convergence criterion for the SCF cycle in Hartrees (default is 1e-7).</p>\n\n<p>dmat_guess_method : str, optional\n    Method for the initial density matrix guess (e.g., 'core', 'huckel').</p>\n\n<p>xc : list or str, optional\n    Exchange-correlation functional specification. If None, defaults to LDA (<code>[1, 7]</code>).</p>\n\n<p>grids : object, optional\n    Precomputed numerical integration grids. If None, they will be generated automatically.</p>\n\n<p>gridsLevel : int, optional\n    Level of numerical integration grid refinement (default is 3).</p>\n\n<p>blocksize : int, optional\n    Block size for XC grid evaluations. Defaults depend on whether GPU is used.</p>\n\n<p>save_ao_values : bool, optional\n    If True, saves AO values to reuse during XC evaluation. Increases speed but uses more memory.</p>\n\n<p>use_gpu : bool, optional\n    Whether to use GPU acceleration.</p>\n\n<p>ncores : int, optional\n    Number of CPU cores to use (default is 2).</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>dmat : ndarray\n    Initial guess for the density matrix, will be computed during setup.</p>\n\n<p>KSmats : list\n    List of Kohn\u2013Sham matrices used in DIIS extrapolation.</p>\n\n<p>errVecs : list\n    List of error vectors for DIIS.</p>\n\n<p>max_itr : int\n    Maximum number of SCF iterations (default is 50).</p>\n\n<p>isDF : bool\n    Whether to use density fitting for Coulomb integrals.</p>\n\n<p>rys : bool\n    Whether to use Rys quadrature for evaluating electron repulsion integrals.</p>\n\n<p>DF_algo : int\n    Algorithm selector for DF (reserved for developer use).</p>\n\n<p>XC_algo : int\n    Algorithm selector for XC evaluation (2 for CPU, 3 for GPU).</p>\n\n<p>sortGrids : bool\n    Whether to sort DFT integration grids (not recommended).</p>\n\n<p>xc_bf_screen : bool\n    Enable basis function screening for XC term evaluation.</p>\n\n<p>threshold_schwarz : float\n    Threshold for Schwarz screening (default is 1e-9).</p>\n\n<p>strict_schwarz : bool\n    If True, applies stricter Schwarz screening.</p>\n\n<p>cholesky : bool\n    If True, uses Cholesky decomposition for DF.</p>\n\n<p>orthogonalize : bool\n    If True, orthogonalizes AO basis functions.</p>\n\n<p>sao : bool\n    If True, uses SAO basis instead of CAO basis.</p>\n\n<p>keep_ao_in_gpu : bool\n    Whether to retain AO values in GPU memory during SCF (if <code>save_ao_values</code> is True).</p>\n\n<p>use_libxc : bool\n    Whether to use LibXC for XC functional evaluation (recommended off for GPU).</p>\n\n<p>n_streams : int\n    Number of CUDA streams to use (if applicable).</p>\n\n<p>n_gpus : int\n    Number of GPUs to use.</p>\n\n<p>free_gpu_mem : bool\n    Whether to forcibly free GPU memory after use.</p>\n\n<p>max_threads_per_block : int\n    Maximum threads per CUDA block supported by the device.</p>\n\n<p>threads_x : int\n    CUDA thread configuration (X dimension).</p>\n\n<p>threads_y : int\n    CUDA thread configuration (Y dimension).</p>\n\n<p>dynamic_precision : bool\n    Whether to use precision switching during XC evaluation for performance gains.</p>\n\n<p>keep_ints3c2e_in_gpu : bool\n    Whether to keep 3-center 2-electron integrals in GPU memory to avoid transfers.</p>\n\n<p>debug : bool\n    If True, prints debugging output during DFT calculations.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This class supports SCF DFT calculations with density fitting (DF).</li>\n<li>GPU support is optional and provides significant speed-up for large systems.</li>\n<li>The class is tightly integrated with PyFock and LibXC libraries.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mol</span> <span class=\"o\">=</span> <span class=\"n\">Molecule</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">basis</span> <span class=\"o\">=</span> <span class=\"n\">Basis</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dft</span> <span class=\"o\">=</span> <span class=\"n\">DFT</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">xc</span><span class=\"o\">=</span><span class=\"s1\">&#39;PBE&#39;</span><span class=\"p\">,</span> <span class=\"n\">use_gpu</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dft</span><span class=\"o\">.</span><span class=\"n\">run_scf</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n"}, {"fullname": "pyfock.DFT.DFT.__init__", "modulename": "pyfock.DFT", "qualname": "DFT.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mol</span>,</span><span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">conv_crit</span><span class=\"o\">=</span><span class=\"mf\">1e-07</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_guess_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">grids</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gridsLevel</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_ao_values</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">use_gpu</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span></span>)</span>"}, {"fullname": "pyfock.DFT.DFT.mol", "modulename": "pyfock.DFT", "qualname": "DFT.mol", "kind": "variable", "doc": "<p>Molecular object for which the DFT calculation will be performed</p>\n"}, {"fullname": "pyfock.DFT.DFT.basis", "modulename": "pyfock.DFT", "qualname": "DFT.basis", "kind": "variable", "doc": "<p>Basis object for corresponding to the molecule for the DFT calculation</p>\n"}, {"fullname": "pyfock.DFT.DFT.dmat_guess_method", "modulename": "pyfock.DFT", "qualname": "DFT.dmat_guess_method", "kind": "variable", "doc": "<p>Initial guess for the density matrix</p>\n"}, {"fullname": "pyfock.DFT.DFT.dmat", "modulename": "pyfock.DFT", "qualname": "DFT.dmat", "kind": "variable", "doc": "<p>Initial density matrix guess for SCF</p>\n"}, {"fullname": "pyfock.DFT.DFT.xc", "modulename": "pyfock.DFT", "qualname": "DFT.xc", "kind": "variable", "doc": "<p>Exchange-Correlation Functional</p>\n"}, {"fullname": "pyfock.DFT.DFT.KSmats", "modulename": "pyfock.DFT", "qualname": "DFT.KSmats", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.errVecs", "modulename": "pyfock.DFT", "qualname": "DFT.errVecs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.diisSpace", "modulename": "pyfock.DFT", "qualname": "DFT.diisSpace", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.conv_crit", "modulename": "pyfock.DFT", "qualname": "DFT.conv_crit", "kind": "variable", "doc": "<p>Convergence criterion for SCF (in Hartrees)</p>\n"}, {"fullname": "pyfock.DFT.DFT.max_itr", "modulename": "pyfock.DFT", "qualname": "DFT.max_itr", "kind": "variable", "doc": "<p>Maximum number of iterations for SCF</p>\n"}, {"fullname": "pyfock.DFT.DFT.ncores", "modulename": "pyfock.DFT", "qualname": "DFT.ncores", "kind": "variable", "doc": "<p>Number of cores to be used for DFT calculation</p>\n"}, {"fullname": "pyfock.DFT.DFT.grids", "modulename": "pyfock.DFT", "qualname": "DFT.grids", "kind": "variable", "doc": "<p>Atomic grids for DFT calculation (If None or not supplied, will be generated using NumGrid)</p>\n"}, {"fullname": "pyfock.DFT.DFT.gridsLevel", "modulename": "pyfock.DFT", "qualname": "DFT.gridsLevel", "kind": "variable", "doc": "<p>Atomic grids for DFT calculation</p>\n"}, {"fullname": "pyfock.DFT.DFT.isDF", "modulename": "pyfock.DFT", "qualname": "DFT.isDF", "kind": "variable", "doc": "<p>Use density fitting (DF) for two-electron Coulomb integrals. This is only for developers. Users should not change it.</p>\n"}, {"fullname": "pyfock.DFT.DFT.auxbasis", "modulename": "pyfock.DFT", "qualname": "DFT.auxbasis", "kind": "variable", "doc": "<p>Basis object to be used as the auxiliary basis for DF</p>\n"}, {"fullname": "pyfock.DFT.DFT.rys", "modulename": "pyfock.DFT", "qualname": "DFT.rys", "kind": "variable", "doc": "<p>Use rys quadrature for the evaluation of two electron integrals (with and without DF)</p>\n"}, {"fullname": "pyfock.DFT.DFT.DF_algo", "modulename": "pyfock.DFT", "qualname": "DFT.DF_algo", "kind": "variable", "doc": "<p>This is only for developers. Users should not change it.</p>\n"}, {"fullname": "pyfock.DFT.DFT.blocksize", "modulename": "pyfock.DFT", "qualname": "DFT.blocksize", "kind": "variable", "doc": "<p>Block size for the evaulation of XC term on grids. For CPUs a value of ~5000 is recommended. For GPUs, a value &gt;20480 is recommended.</p>\n"}, {"fullname": "pyfock.DFT.DFT.XC_algo", "modulename": "pyfock.DFT", "qualname": "DFT.XC_algo", "kind": "variable", "doc": "<p>This is only for developers. Users should not change it. The algorithm for XC evaluation should be 2 for CPU and 3 for GPU.</p>\n"}, {"fullname": "pyfock.DFT.DFT.debug", "modulename": "pyfock.DFT", "qualname": "DFT.debug", "kind": "variable", "doc": "<p>Turn on printing debug statements</p>\n"}, {"fullname": "pyfock.DFT.DFT.sortGrids", "modulename": "pyfock.DFT", "qualname": "DFT.sortGrids", "kind": "variable", "doc": "<p>Enable/Disable sorting of DFT grids. Doesn't seem to offer any signficant advantage.</p>\n"}, {"fullname": "pyfock.DFT.DFT.save_ao_values", "modulename": "pyfock.DFT", "qualname": "DFT.save_ao_values", "kind": "variable", "doc": "<p>Whether to save atomic orbital (AO) values for reuse during XC evaluation. Improves performance but requires more memory.</p>\n"}, {"fullname": "pyfock.DFT.DFT.xc_bf_screen", "modulename": "pyfock.DFT", "qualname": "DFT.xc_bf_screen", "kind": "variable", "doc": "<p>Enable screening of basis functions for XC term evaluation to reduce computation time drastically.</p>\n"}, {"fullname": "pyfock.DFT.DFT.threshold_schwarz", "modulename": "pyfock.DFT", "qualname": "DFT.threshold_schwarz", "kind": "variable", "doc": "<p>Threshold for Schwarz screening of two-electron integrals. Smaller values increase accuracy but reduce sparsity.</p>\n"}, {"fullname": "pyfock.DFT.DFT.strict_schwarz", "modulename": "pyfock.DFT", "qualname": "DFT.strict_schwarz", "kind": "variable", "doc": "<p>If True, enforce stricter Schwarz screening to aggressively eliminate small two-electron integrals.</p>\n"}, {"fullname": "pyfock.DFT.DFT.cholesky", "modulename": "pyfock.DFT", "qualname": "DFT.cholesky", "kind": "variable", "doc": "<p>Whether to use Cholesky decomposition for DF. Slightly speeds up calculations.</p>\n"}, {"fullname": "pyfock.DFT.DFT.orthogonalize", "modulename": "pyfock.DFT", "qualname": "DFT.orthogonalize", "kind": "variable", "doc": "<p>Apply orthogonalization to the AO basis. Should be True for most standard calculations.</p>\n"}, {"fullname": "pyfock.DFT.DFT.sao", "modulename": "pyfock.DFT", "qualname": "DFT.sao", "kind": "variable", "doc": "<p>Whether to use SAO basis or CAO basis. Default is CAO basis.</p>\n"}, {"fullname": "pyfock.DFT.DFT.use_gpu", "modulename": "pyfock.DFT", "qualname": "DFT.use_gpu", "kind": "variable", "doc": "<p>Whether to use GPU acceleration or not</p>\n"}, {"fullname": "pyfock.DFT.DFT.keep_ao_in_gpu", "modulename": "pyfock.DFT", "qualname": "DFT.keep_ao_in_gpu", "kind": "variable", "doc": "<p>Whether to keep the atomic orbitals for XC evaluation in GPU memory or CPU memory. Only relevant if save_ao_values = True.</p>\n"}, {"fullname": "pyfock.DFT.DFT.use_libxc", "modulename": "pyfock.DFT", "qualname": "DFT.use_libxc", "kind": "variable", "doc": "<p>Whether to use LibXC's version of XC functionals or PyFock implementations. \nOnly relevant when GPU is used. For GPU calculations it is recommended to use PyFock \nimplementation as it avoids CPU-GPU transfers.</p>\n"}, {"fullname": "pyfock.DFT.DFT.n_streams", "modulename": "pyfock.DFT", "qualname": "DFT.n_streams", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.n_gpus", "modulename": "pyfock.DFT", "qualname": "DFT.n_gpus", "kind": "variable", "doc": "<p>Number of GPUs to be used</p>\n"}, {"fullname": "pyfock.DFT.DFT.free_gpu_mem", "modulename": "pyfock.DFT", "qualname": "DFT.free_gpu_mem", "kind": "variable", "doc": "<p>Whether the GPU memory should be freed by force or not</p>\n"}, {"fullname": "pyfock.DFT.DFT.threads_x", "modulename": "pyfock.DFT", "qualname": "DFT.threads_x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.threads_y", "modulename": "pyfock.DFT", "qualname": "DFT.threads_y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.DFT.DFT.dynamic_precision", "modulename": "pyfock.DFT", "qualname": "DFT.dynamic_precision", "kind": "variable", "doc": "<p>Whether to use dynamic precision switching for XC term or not</p>\n"}, {"fullname": "pyfock.DFT.DFT.keep_ints3c2e_in_gpu", "modulename": "pyfock.DFT", "qualname": "DFT.keep_ints3c2e_in_gpu", "kind": "variable", "doc": "<p>Whether to keep the 3c2e integrals in GPU memory or not. \nRecommended to keep in GPU memory to avoid CPU-GPU transfers at each iteration.</p>\n"}, {"fullname": "pyfock.DFT.DFT.nuclear_rep_energy", "modulename": "pyfock.DFT", "qualname": "DFT.nuclear_rep_energy", "kind": "function", "doc": "<p>Compute the nuclear-nuclear repulsion energy.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule, optional\n    Molecule object containing nuclear coordinates and charges. \n    If None, uses <code>self.mol</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The nuclear repulsion energy in Hartrees.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.gen_dm", "modulename": "pyfock.DFT", "qualname": "DFT.gen_dm", "kind": "function", "doc": "<p>Generate the density matrix from molecular orbital coefficients and occupations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mo_coeff : ndarray\n    Molecular orbital coefficient matrix.</p>\n\n<p>mo_occ : ndarray\n    Array of MO occupation numbers.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Density matrix (RHF/RKS type).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mo_coeff</span>, </span><span class=\"param\"><span class=\"n\">mo_occ</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.getOcc", "modulename": "pyfock.DFT", "qualname": "DFT.getOcc", "kind": "function", "doc": "<p>Assign occupation numbers to molecular orbitals based on their energies.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule\n    Molecule object to extract the number of electrons.</p>\n\n<p>energy_mo : ndarray\n    Array of MO energies.</p>\n\n<p>coeff_mo : ndarray\n    Array of MO coefficients (not used but kept for compatibility).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Array of MO occupations (0 or 2 for RHF).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">energy_mo</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">coeff_mo</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.gen_dm_cupy", "modulename": "pyfock.DFT", "qualname": "DFT.gen_dm_cupy", "kind": "function", "doc": "<p>Generate the density matrix using CuPy for GPU acceleration.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mo_coeff : cp.ndarray\n    Molecular orbital coefficient matrix (on GPU).</p>\n\n<p>mo_occ : cp.ndarray\n    Array of MO occupation numbers (on GPU).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cp.ndarray\n    Density matrix (RHF/RKS type) computed on the GPU.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mo_coeff</span>, </span><span class=\"param\"><span class=\"n\">mo_occ</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.getOcc_cupy", "modulename": "pyfock.DFT", "qualname": "DFT.getOcc_cupy", "kind": "function", "doc": "<p>Assign occupation numbers to MOs using CuPy (for GPU-based calculations).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule\n    Molecule object to determine number of electrons.</p>\n\n<p>energy_mo : cp.ndarray\n    MO energy array on the GPU.</p>\n\n<p>coeff_mo : cp.ndarray\n    MO coefficients array on the GPU (not used).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cp.ndarray\n    Array of MO occupations (on GPU).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">energy_mo</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">coeff_mo</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.solve", "modulename": "pyfock.DFT", "qualname": "DFT.solve", "kind": "function", "doc": "<p>Solve the generalized or canonical eigenvalue equation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>H : ndarray\n    Hamiltonian matrix.</p>\n\n<p>S : ndarray\n    Overlap matrix.</p>\n\n<p>orthogonalize : bool, optional\n    If True, solve using orthogonalized basis.</p>\n\n<p>x : ndarray, optional\n    Transformation matrix (if already computed).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of (ndarray, ndarray)\n    Eigenvalues and eigenvectors of the system.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">S</span>, </span><span class=\"param\"><span class=\"n\">orthogonalize</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.solve_cupy", "modulename": "pyfock.DFT", "qualname": "DFT.solve_cupy", "kind": "function", "doc": "<p>Solve the generalized eigenvalue problem using CuPy (GPU).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>H : cp.ndarray\n    Hamiltonian matrix (on GPU).</p>\n\n<p>S : cp.ndarray\n    Overlap matrix (on GPU).</p>\n\n<p>orthogonalize : bool, optional\n    If True, solve using orthogonalized basis.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of (cp.ndarray, cp.ndarray)\n    Eigenvalues and eigenvectors (on GPU).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">H</span>, </span><span class=\"param\"><span class=\"n\">S</span>, </span><span class=\"param\"><span class=\"n\">orthogonalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.getCoreH", "modulename": "pyfock.DFT", "qualname": "DFT.getCoreH", "kind": "function", "doc": "<p>Compute the core Hamiltonian matrix (T + V).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule, optional\n    Molecule object.</p>\n\n<p>basis : Basis, optional\n    Basis set object.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Core Hamiltonian matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">basis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.guessCoreH", "modulename": "pyfock.DFT", "qualname": "DFT.guessCoreH", "kind": "function", "doc": "<p>Generate a guess density matrix using the core Hamiltonian.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : Molecule, optional\n    Molecule object.</p>\n\n<p>basis : Basis, optional\n    Basis set.</p>\n\n<p>Hcore : ndarray, optional\n    Core Hamiltonian. If None, it will be computed.</p>\n\n<p>S : ndarray, optional\n    Overlap matrix. If None, it will be computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Initial guess density matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">basis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">Hcore</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">S</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.DIIS", "modulename": "pyfock.DFT", "qualname": "DFT.DIIS", "kind": "function", "doc": "<p>Perform Direct Inversion in the Iterative Subspace (DIIS) to improve SCF convergence.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>McMurchie-Davidson project:\n<a href=\"https://github.com/jjgoings/McMurchie-Davidson\">https://github.com/jjgoings/McMurchie-Davidson</a>\nLicensed under the BSD-3-Clause license</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>S : ndarray\n    Overlap matrix.</p>\n\n<p>D : ndarray\n    Density matrix.</p>\n\n<p>F : ndarray\n    Fock matrix.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    DIIS-extrapolated Fock matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">S</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.DIIS_cupy", "modulename": "pyfock.DFT", "qualname": "DFT.DIIS_cupy", "kind": "function", "doc": "<p>Perform DIIS on GPU using CuPy to accelerate SCF convergence.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>McMurchie-Davidson project:\n<a href=\"https://github.com/jjgoings/McMurchie-Davidson\">https://github.com/jjgoings/McMurchie-Davidson</a>\nLicensed under the BSD-3-Clause license</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>S : cp.ndarray\n    Overlap matrix (on GPU).</p>\n\n<p>D : cp.ndarray\n    Density matrix (on GPU).</p>\n\n<p>F : cp.ndarray\n    Fock matrix (on GPU).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cp.ndarray\n    DIIS-extrapolated Fock matrix (on GPU).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">S</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.DFT.DFT.scf", "modulename": "pyfock.DFT", "qualname": "DFT.scf", "kind": "function", "doc": "<p>Perform Self-Consistent Field (SCF) calculation for Density Functional Theory (DFT).</p>\n\n<p>This method implements a complete DFT SCF procedure including:</p>\n\n<ul>\n<li>One-electron integral calculation (overlap, kinetic, nuclear attraction)</li>\n<li>Two-electron integral calculation (4-center ERIs or density fitting)</li>\n<li>Grid generation and pruning for exchange-correlation evaluation</li>\n<li>Iterative SCF cycles with DIIS convergence acceleration</li>\n<li>Exchange-correlation energy and potential evaluation using LibXC</li>\n<li>GPU acceleration support for performance-critical operations</li>\n</ul>\n\n<p>The implementation supports multiple algorithmic variants:</p>\n\n<ul>\n<li>Density fitting (DF)</li>\n<li>Schwarz screening for integral sparsity</li>\n<li>Multiple XC evaluation algorithms (CPU/GPU optimized)</li>\n<li>Dynamic precision switching for GPU calculations</li>\n</ul>\n\n<p>SCF Procedure:</p>\n\n<ol>\n<li>Initialize one-electron integrals (S, T, V_nuc)</li>\n<li>Calculate/prepare two-electron integrals with optional screening</li>\n<li>Generate and prune integration grids for XC evaluation</li>\n<li>Iterative SCF loop:</li>\n</ol>\n\n<ul>\n<li>Build Coulomb matrix J from density matrix</li>\n<li>Evaluate exchange-correlation energy/potential on grids</li>\n<li>Form Kohn-Sham matrix: H_KS = H_core + J + V_xc</li>\n<li>Apply DIIS convergence acceleration</li>\n<li>Diagonalize KS matrix to get new orbitals</li>\n<li>Generate new density matrix from occupied orbitals</li>\n<li>Check energy convergence</li>\n</ul>\n\n<ol start=\"5\">\n<li>Return converged total energy and density matrix</li>\n</ol>\n\n<p>Computational Features:</p>\n\n<ul>\n<li>Multi-threading support via Numba and configurable core count</li>\n<li>GPU acceleration using CuPy for grid-based operations</li>\n<li>Memory-efficient batched evaluation of XC terms</li>\n<li>Multiple density fitting algorithms (DF_algo 1-10)</li>\n<li>Basis function screening for XC evaluation efficiency</li>\n<li>Optional Cholesky decomposition for 2-center integrals</li>\n</ul>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple[float, numpy.ndarray]\n    Etot : float\n        Converged total electronic energy in atomic units\n    dmat : numpy.ndarray, shape (nbf, nbf)\n        Converged density matrix in atomic orbital basis</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p>ConvergenceError\n    If SCF fails to converge within max_itr iterations</p>\n\n<h2 id=\"notes\">Notes:</h2>\n\n<ul>\n<li>Uses class attributes for all computational parameters (basis, xc, conv_crit, etc.)</li>\n<li>Extensive timing and profiling information printed during execution</li>\n<li>Memory usage information displayed for large arrays</li>\n<li>GPU memory automatically freed after completion</li>\n<li>Supports both Cartesian (CAO) and Spherical (SAO) atomic orbital bases</li>\n</ul>\n\n<p>The function performs comprehensive error checking and provides detailed\ntiming breakdowns for performance analysis. GPU acceleration is automatically\nenabled when CuPy is available and use_gpu=True.</p>\n\n<p>Example Energy Components:</p>\n\n<ul>\n<li>Electron-nuclear attraction energy</li>\n<li>Nuclear repulsion energy  </li>\n<li>Kinetic energy</li>\n<li>Coulomb (electron-electron repulsion) energy</li>\n<li>Exchange-correlation energy</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Data", "modulename": "pyfock.Data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Data.Data", "modulename": "pyfock.Data", "qualname": "Data", "kind": "class", "doc": "<p>A container class holding atomic and basis set metadata used in calculations using PyFock.</p>\n\n<p>This includes element symbols, names, covalent and atomic radii, atomic masses, shell definitions,\nand other constants and mappings relevant for electronic structure calculations.</p>\n\n<p>Note: Index 0 in all element-related lists corresponds to a ghost atom (used in some basis set techniques).</p>\n"}, {"fullname": "pyfock.Data.Data.elementSymbols", "modulename": "pyfock.Data", "qualname": "Data.elementSymbols", "kind": "variable", "doc": "<p>List of chemical element symbols. Index 0 is reserved for the ghost atom.</p>\n", "default_value": "[&#x27;Ghost&#x27;, &#x27;H&#x27;, &#x27;He&#x27;, &#x27;Li&#x27;, &#x27;Be&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;F&#x27;, &#x27;Ne&#x27;, &#x27;Na&#x27;, &#x27;Mg&#x27;, &#x27;Al&#x27;, &#x27;Si&#x27;, &#x27;P&#x27;, &#x27;S&#x27;, &#x27;Cl&#x27;, &#x27;Ar&#x27;, &#x27;K&#x27;, &#x27;Ca&#x27;, &#x27;Sc&#x27;, &#x27;Ti&#x27;, &#x27;V&#x27;, &#x27;Cr&#x27;, &#x27;Mn&#x27;, &#x27;Fe&#x27;, &#x27;Co&#x27;, &#x27;Ni&#x27;, &#x27;Cu&#x27;, &#x27;Zn&#x27;, &#x27;Ga&#x27;, &#x27;Ge&#x27;, &#x27;As&#x27;, &#x27;Se&#x27;, &#x27;Br&#x27;, &#x27;Kr&#x27;, &#x27;Rb&#x27;, &#x27;Sr&#x27;, &#x27;Y&#x27;, &#x27;Zr&#x27;, &#x27;Nb&#x27;, &#x27;Mo&#x27;, &#x27;Tc&#x27;, &#x27;Ru&#x27;, &#x27;Rh&#x27;, &#x27;Pd&#x27;, &#x27;Ag&#x27;, &#x27;Cd&#x27;, &#x27;In&#x27;, &#x27;Sn&#x27;, &#x27;Sb&#x27;, &#x27;Te&#x27;, &#x27;I&#x27;, &#x27;Xe&#x27;, &#x27;Cs&#x27;, &#x27;Ba&#x27;, &#x27;La&#x27;, &#x27;Ce&#x27;, &#x27;Pr&#x27;, &#x27;Nd&#x27;, &#x27;Pm&#x27;, &#x27;Sm&#x27;, &#x27;Eu&#x27;, &#x27;Gd&#x27;, &#x27;Tb&#x27;, &#x27;Dy&#x27;, &#x27;Ho&#x27;, &#x27;Er&#x27;, &#x27;Tm&#x27;, &#x27;Yb&#x27;, &#x27;Lu&#x27;, &#x27;Hf&#x27;, &#x27;Ta&#x27;, &#x27;W&#x27;, &#x27;Re&#x27;, &#x27;Os&#x27;, &#x27;Ir&#x27;, &#x27;Pt&#x27;, &#x27;Au&#x27;, &#x27;Hg&#x27;, &#x27;Tl&#x27;, &#x27;Pb&#x27;, &#x27;Bi&#x27;, &#x27;Po&#x27;, &#x27;At&#x27;, &#x27;Rn&#x27;, &#x27;Fr&#x27;, &#x27;Ra&#x27;, &#x27;Ac&#x27;, &#x27;Th&#x27;, &#x27;Pa&#x27;, &#x27;U&#x27;, &#x27;Np&#x27;, &#x27;Pu&#x27;, &#x27;Am&#x27;, &#x27;Cm&#x27;, &#x27;Bk&#x27;, &#x27;Cf&#x27;, &#x27;Es&#x27;, &#x27;Fm&#x27;, &#x27;Md&#x27;, &#x27;No&#x27;, &#x27;Lr&#x27;, &#x27;Rf&#x27;, &#x27;Db&#x27;, &#x27;Sg&#x27;, &#x27;Bh&#x27;, &#x27;Hs&#x27;, &#x27;Mt&#x27;, &#x27;Ds&#x27;, &#x27;Rg&#x27;, &#x27;Cn&#x27;, &#x27;Nh&#x27;, &#x27;Fl&#x27;, &#x27;Mc&#x27;, &#x27;Lv&#x27;, &#x27;Ts&#x27;, &#x27;Og&#x27;]"}, {"fullname": "pyfock.Data.Data.elementName", "modulename": "pyfock.Data", "qualname": "Data.elementName", "kind": "variable", "doc": "<p>Full names of the elements corresponding to <code>elementSymbols</code>.</p>\n", "default_value": "[&#x27;Ghost&#x27;, &#x27;Hydrogen&#x27;, &#x27;Helium&#x27;, &#x27;Lithium&#x27;, &#x27;Beryllium&#x27;, &#x27;Boron&#x27;, &#x27;Carbon&#x27;, &#x27;Nitrogen&#x27;, &#x27;Oxygen&#x27;, &#x27;Fluorine&#x27;, &#x27;Neon&#x27;, &#x27;Sodium&#x27;, &#x27;Magnesium&#x27;, &#x27;Aluminum&#x27;, &#x27;Silicon&#x27;, &#x27;Phosphorus&#x27;, &#x27;Sulfur&#x27;, &#x27;Chlorine&#x27;, &#x27;Argon&#x27;, &#x27;Potassium&#x27;, &#x27;Calcium&#x27;, &#x27;Scandium&#x27;, &#x27;Titanium&#x27;, &#x27;Vanadium&#x27;, &#x27;Chromium&#x27;, &#x27;Manganese&#x27;, &#x27;Iron&#x27;, &#x27;Cobalt&#x27;, &#x27;Nickel&#x27;, &#x27;Copper&#x27;, &#x27;Zinc&#x27;, &#x27;Gallium&#x27;, &#x27;Germanium&#x27;, &#x27;Arsenic&#x27;, &#x27;Selenium&#x27;, &#x27;Bromine&#x27;, &#x27;Krypton&#x27;, &#x27;Rubidium&#x27;, &#x27;Strontium&#x27;, &#x27;Yttrium&#x27;, &#x27;Zirconium&#x27;, &#x27;Niobium&#x27;, &#x27;Molybdenum&#x27;, &#x27;Technetium&#x27;, &#x27;Ruthenium&#x27;, &#x27;Rhodium&#x27;, &#x27;Palladium&#x27;, &#x27;Silver&#x27;, &#x27;Cadmium&#x27;, &#x27;Indium&#x27;, &#x27;Tin&#x27;, &#x27;Antimony&#x27;, &#x27;Tellurium&#x27;, &#x27;Iodine&#x27;, &#x27;Xenon&#x27;, &#x27;Cesium&#x27;, &#x27;Barium&#x27;, &#x27;Lanthanum&#x27;, &#x27;Cerium&#x27;, &#x27;Praseodymium&#x27;, &#x27;Neodymium&#x27;, &#x27;Promethium&#x27;, &#x27;Samarium&#x27;, &#x27;Europium&#x27;, &#x27;Gadolinium&#x27;, &#x27;Terbium&#x27;, &#x27;Dysprosium&#x27;, &#x27;Holmium&#x27;, &#x27;Erbium&#x27;, &#x27;Thulium&#x27;, &#x27;Ytterbium&#x27;, &#x27;Lutetium&#x27;, &#x27;Hafnium&#x27;, &#x27;Tantalum&#x27;, &#x27;Tungsten&#x27;, &#x27;Rhenium&#x27;, &#x27;Osmium&#x27;, &#x27;Iridium&#x27;, &#x27;Platinum&#x27;, &#x27;Gold&#x27;, &#x27;Mercury&#x27;, &#x27;Thallium&#x27;, &#x27;Lead&#x27;, &#x27;Bismuth&#x27;, &#x27;Polonium&#x27;, &#x27;Astatine&#x27;, &#x27;Radon&#x27;, &#x27;Francium&#x27;, &#x27;Radium&#x27;, &#x27;Actinium&#x27;, &#x27;Thorium&#x27;, &#x27;Protactinium&#x27;, &#x27;Uranium&#x27;, &#x27;Neptunium&#x27;, &#x27;Plutonium&#x27;, &#x27;Americium&#x27;, &#x27;Curium&#x27;, &#x27;Berkelium&#x27;, &#x27;Californium&#x27;, &#x27;Einsteinium&#x27;, &#x27;Fermium&#x27;, &#x27;Mendelevium&#x27;, &#x27;Nobelium&#x27;, &#x27;Lawrencium&#x27;, &#x27;Rutherfordium&#x27;, &#x27;Dubnium&#x27;, &#x27;Seaborgium&#x27;, &#x27;Bohrium&#x27;, &#x27;Hassium&#x27;, &#x27;Meitnerium&#x27;, &#x27;Darmstadtium&#x27;, &#x27;Roentgenium&#x27;, &#x27;Copernicium&#x27;, &#x27;Nihonium&#x27;, &#x27;Flerovium&#x27;, &#x27;Moscovium&#x27;, &#x27;Livermorium&#x27;, &#x27;Tennessine&#x27;, &#x27;Oganesson&#x27;]"}, {"fullname": "pyfock.Data.Data.covalentRadius", "modulename": "pyfock.Data", "qualname": "Data.covalentRadius", "kind": "variable", "doc": "<p>Covalent radii of elements in \u00c5ngstr\u00f6ms. Some entries may be \"N/A\" if unknown or undefined.</p>\n", "default_value": "[&#x27;0&#x27;, &#x27;0.37&#x27;, &#x27;0.32&#x27;, &#x27;1.34&#x27;, &#x27;0.9&#x27;, &#x27;0.82&#x27;, &#x27;0.77&#x27;, &#x27;0.75&#x27;, &#x27;0.73&#x27;, &#x27;0.71&#x27;, &#x27;0.69&#x27;, &#x27;1.54&#x27;, &#x27;1.3&#x27;, &#x27;1.18&#x27;, &#x27;1.11&#x27;, &#x27;1.06&#x27;, &#x27;1.02&#x27;, &#x27;0.99&#x27;, &#x27;0.97&#x27;, &#x27;1.96&#x27;, &#x27;1.74&#x27;, &#x27;1.44&#x27;, &#x27;1.36&#x27;, &#x27;1.25&#x27;, &#x27;1.27&#x27;, &#x27;1.39&#x27;, &#x27;1.25&#x27;, &#x27;1.26&#x27;, &#x27;1.21&#x27;, &#x27;1.38&#x27;, &#x27;1.31&#x27;, &#x27;1.26&#x27;, &#x27;1.22&#x27;, &#x27;1.19&#x27;, &#x27;1.16&#x27;, &#x27;1.14&#x27;, &#x27;1.1&#x27;, &#x27;2.11&#x27;, &#x27;1.92&#x27;, &#x27;1.62&#x27;, &#x27;1.48&#x27;, &#x27;1.37&#x27;, &#x27;1.45&#x27;, &#x27;1.56&#x27;, &#x27;1.26&#x27;, &#x27;1.35&#x27;, &#x27;1.31&#x27;, &#x27;1.53&#x27;, &#x27;1.48&#x27;, &#x27;1.44&#x27;, &#x27;1.41&#x27;, &#x27;1.38&#x27;, &#x27;1.35&#x27;, &#x27;1.33&#x27;, &#x27;1.3&#x27;, &#x27;2.25&#x27;, &#x27;1.98&#x27;, &#x27;1.69&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;1.6&#x27;, &#x27;1.5&#x27;, &#x27;1.38&#x27;, &#x27;1.46&#x27;, &#x27;1.59&#x27;, &#x27;1.28&#x27;, &#x27;1.37&#x27;, &#x27;1.28&#x27;, &#x27;1.44&#x27;, &#x27;1.49&#x27;, &#x27;1.48&#x27;, &#x27;1.47&#x27;, &#x27;1.46&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;1.45&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;]"}, {"fullname": "pyfock.Data.Data.massNumber", "modulename": "pyfock.Data", "qualname": "Data.massNumber", "kind": "variable", "doc": "<p>Atomic masses of elements in unified atomic mass units (u). Values in brackets indicate unstable isotopes.</p>\n", "default_value": "[&#x27;0&#x27;, &#x27;1.007944&#x27;, &#x27;4.0026022&#x27;, &#x27;6.9412&#x27;, &#x27;9.0121823&#x27;, &#x27;10.8117&#x27;, &#x27;12.01078&#x27;, &#x27;14.00672&#x27;, &#x27;15.99943&#x27;, &#x27;18.99840325&#x27;, &#x27;20.17976&#x27;, &#x27;22.989769282&#x27;, &#x27;24.30506&#x27;, &#x27;26.98153868&#x27;, &#x27;28.08553&#x27;, &#x27;30.9737622&#x27;, &#x27;32.0655&#x27;, &#x27;35.4532&#x27;, &#x27;39.9481&#x27;, &#x27;39.09831&#x27;, &#x27;40.0784&#x27;, &#x27;44.9559126&#x27;, &#x27;47.8671&#x27;, &#x27;50.94151&#x27;, &#x27;51.99616&#x27;, &#x27;54.9380455&#x27;, &#x27;55.8452&#x27;, &#x27;58.9331955&#x27;, &#x27;58.69344&#x27;, &#x27;63.5463&#x27;, &#x27;65.382&#x27;, &#x27;69.7231&#x27;, &#x27;72.641&#x27;, &#x27;74.921602&#x27;, &#x27;78.963&#x27;, &#x27;79.9041&#x27;, &#x27;83.7982&#x27;, &#x27;85.46783&#x27;, &#x27;87.621&#x27;, &#x27;88.905852&#x27;, &#x27;91.2242&#x27;, &#x27;92.906382&#x27;, &#x27;95.962&#x27;, &#x27;[98]&#x27;, &#x27;101.072&#x27;, &#x27;102.905502&#x27;, &#x27;106.421&#x27;, &#x27;107.86822&#x27;, &#x27;112.4118&#x27;, &#x27;114.8183&#x27;, &#x27;118.7107&#x27;, &#x27;121.7601&#x27;, &#x27;127.603&#x27;, &#x27;126.904473&#x27;, &#x27;131.2936&#x27;, &#x27;132.90545192&#x27;, &#x27;137.3277&#x27;, &#x27;138.905477&#x27;, &#x27;140.1161&#x27;, &#x27;140.907652&#x27;, &#x27;144.2423&#x27;, &#x27;[145]&#x27;, &#x27;150.362&#x27;, &#x27;151.9641&#x27;, &#x27;157.253&#x27;, &#x27;158.925352&#x27;, &#x27;162.5001&#x27;, &#x27;164.930322&#x27;, &#x27;167.2593&#x27;, &#x27;168.934212&#x27;, &#x27;173.0545&#x27;, &#x27;174.96681&#x27;, &#x27;178.492&#x27;, &#x27;180.947882&#x27;, &#x27;183.841&#x27;, &#x27;186.2071&#x27;, &#x27;190.233&#x27;, &#x27;192.2173&#x27;, &#x27;195.0849&#x27;, &#x27;196.9665694&#x27;, &#x27;200.592&#x27;, &#x27;204.38332&#x27;, &#x27;207.21&#x27;, &#x27;208.980401&#x27;, &#x27;[209]&#x27;, &#x27;[210]&#x27;, &#x27;[222]&#x27;, &#x27;[223]&#x27;, &#x27;[226]&#x27;, &#x27;[227]&#x27;, &#x27;232.038062&#x27;, &#x27;231.035882&#x27;, &#x27;238.028913&#x27;, &#x27;[237]&#x27;, &#x27;[244]&#x27;, &#x27;[243]&#x27;, &#x27;[247]&#x27;, &#x27;[247]&#x27;, &#x27;[251]&#x27;, &#x27;[252]&#x27;, &#x27;[257]&#x27;, &#x27;[258]&#x27;, &#x27;[259]&#x27;, &#x27;[262]&#x27;, &#x27;[267]&#x27;, &#x27;[268]&#x27;, &#x27;[271]&#x27;, &#x27;[272]&#x27;, &#x27;[270]&#x27;, &#x27;[276]&#x27;, &#x27;[281]&#x27;, &#x27;[280]&#x27;, &#x27;[285]&#x27;, &#x27;[284]&#x27;, &#x27;[289]&#x27;, &#x27;[288]&#x27;, &#x27;[293]&#x27;, &#x27;[294]&#x27;, &#x27;[294]&#x27;]"}, {"fullname": "pyfock.Data.Data.atomicRadius", "modulename": "pyfock.Data", "qualname": "Data.atomicRadius", "kind": "variable", "doc": "<p>Atomic radii in \u00c5ngstr\u00f6ms, representing empirical or van der Waals sizes. \"N/A\" indicates missing data.</p>\n", "default_value": "[&#x27;0.4&#x27;, &#x27;0.53&#x27;, &#x27;0.31&#x27;, &#x27;1.67&#x27;, &#x27;1.12&#x27;, &#x27;0.87&#x27;, &#x27;0.67&#x27;, &#x27;0.56&#x27;, &#x27;0.73&#x27;, &#x27;0.42&#x27;, &#x27;0.38&#x27;, &#x27;1.9&#x27;, &#x27;1.45&#x27;, &#x27;1.18&#x27;, &#x27;1.11&#x27;, &#x27;0.98&#x27;, &#x27;0.88&#x27;, &#x27;0.79&#x27;, &#x27;0.71&#x27;, &#x27;2.43&#x27;, &#x27;1.94&#x27;, &#x27;1.84&#x27;, &#x27;1.76&#x27;, &#x27;1.71&#x27;, &#x27;1.66&#x27;, &#x27;1.61&#x27;, &#x27;1.56&#x27;, &#x27;1.52&#x27;, &#x27;1.49&#x27;, &#x27;1.45&#x27;, &#x27;1.42&#x27;, &#x27;1.36&#x27;, &#x27;1.25&#x27;, &#x27;1.14&#x27;, &#x27;1.03&#x27;, &#x27;0.94&#x27;, &#x27;0.88&#x27;, &#x27;2.65&#x27;, &#x27;2.19&#x27;, &#x27;2.12&#x27;, &#x27;2.06&#x27;, &#x27;1.98&#x27;, &#x27;1.9&#x27;, &#x27;1.83&#x27;, &#x27;1.78&#x27;, &#x27;1.73&#x27;, &#x27;1.69&#x27;, &#x27;1.65&#x27;, &#x27;1.61&#x27;, &#x27;1.56&#x27;, &#x27;1.45&#x27;, &#x27;1.33&#x27;, &#x27;1.23&#x27;, &#x27;1.15&#x27;, &#x27;1.08&#x27;, &#x27;2.98&#x27;, &#x27;2.53&#x27;, &#x27;1.95&#x27;, &#x27;1.85&#x27;, &#x27;2.47&#x27;, &#x27;2.06&#x27;, &#x27;2.05&#x27;, &#x27;2.38&#x27;, &#x27;2.31&#x27;, &#x27;2.33&#x27;, &#x27;2.25&#x27;, &#x27;2.28&#x27;, &#x27;2.26&#x27;, &#x27;2.26&#x27;, &#x27;2.22&#x27;, &#x27;2.22&#x27;, &#x27;2.17&#x27;, &#x27;2.08&#x27;, &#x27;2&#x27;, &#x27;1.93&#x27;, &#x27;1.88&#x27;, &#x27;1.85&#x27;, &#x27;1.8&#x27;, &#x27;1.77&#x27;, &#x27;1.74&#x27;, &#x27;1.71&#x27;, &#x27;1.56&#x27;, &#x27;1.54&#x27;, &#x27;1.43&#x27;, &#x27;1.35&#x27;, &#x27;1.27&#x27;, &#x27;1.2&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;1.95&#x27;, &#x27;1.8&#x27;, &#x27;1.8&#x27;, &#x27;1.75&#x27;, &#x27;1.75&#x27;, &#x27;1.75&#x27;, &#x27;1.75&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;, &#x27;N/A&#x27;]"}, {"fullname": "pyfock.Data.Data.CPKcolorRGB", "modulename": "pyfock.Data", "qualname": "Data.CPKcolorRGB", "kind": "variable", "doc": "<p>RGB values used for coloring atoms in molecular visualizations (e.g., CPK coloring scheme).</p>\n", "default_value": "[[255, 255, 255], [255, 255, 255], [217, 255, 255], [204, 128, 255], [194, 255, 0], [255, 181, 181], [144, 144, 144], [48, 80, 248], [255, 13, 13], [144, 224, 80], [179, 227, 245], [171, 92, 242], [138, 255, 0], [191, 166, 166], [240, 200, 160], [255, 128, 0], [255, 255, 48], [31, 240, 31], [128, 209, 227], [143, 64, 212], [61, 255, 0], [230, 230, 230], [191, 194, 199], [166, 166, 171], [138, 153, 199], [156, 122, 199], [224, 102, 51], [240, 144, 160], [80, 208, 80], [200, 128, 51], [125, 128, 176], [194, 143, 143], [102, 143, 143], [189, 128, 227], [255, 161, 0], [166, 41, 41], [92, 184, 209], [112, 46, 176], [0, 255, 0], [148, 255, 255], [148, 224, 224], [115, 194, 201], [84, 181, 181], [59, 158, 158], [36, 143, 143], [10, 125, 140], [0, 105, 133], [192, 192, 192], [255, 217, 143], [166, 117, 115], [102, 128, 128], [158, 99, 181], [212, 122, 0], [148, 0, 148], [66, 158, 176], [87, 23, 143], [0, 201, 0], [112, 212, 255], [255, 255, 199], [217, 255, 199], [199, 255, 199], [163, 255, 199], [143, 255, 199], [97, 255, 199], [69, 255, 199], [48, 255, 199], [31, 255, 199], [0, 255, 156], [0, 230, 117], [0, 212, 82], [0, 191, 56], [0, 171, 36], [77, 194, 255], [77, 166, 255], [33, 148, 214], [38, 125, 171], [38, 102, 150], [23, 84, 135], [208, 208, 224], [255, 209, 35], [184, 184, 208], [166, 84, 77], [87, 89, 97], [158, 79, 181], [171, 92, 0], [117, 79, 69], [66, 130, 150], [66, 0, 102], [0, 125, 0], [112, 171, 250], [0, 186, 255], [0, 161, 255], [0, 143, 255], [0, 128, 255], [0, 107, 255], [84, 92, 242], [120, 92, 227], [138, 79, 227], [161, 54, 212], [179, 31, 212], [179, 31, 186], [179, 13, 166], [189, 13, 135], [199, 0, 102], [204, 0, 89], [209, 0, 79], [217, 0, 69], [224, 0, 56], [230, 0, 46], [235, 0, 38]]"}, {"fullname": "pyfock.Data.Data.Bohr2AngsFactor", "modulename": "pyfock.Data", "qualname": "Data.Bohr2AngsFactor", "kind": "variable", "doc": "<p>Conversion factor from Bohr to \u00c5ngstr\u00f6m (1 Bohr = 0.52917721092 \u00c5).</p>\n", "default_value": "0.52917721092"}, {"fullname": "pyfock.Data.Data.Angs2BohrFactor", "modulename": "pyfock.Data", "qualname": "Data.Angs2BohrFactor", "kind": "variable", "doc": "<p>Conversion factor from \u00c5ngstr\u00f6m to Bohr (1 \u00c5 = 1.88972612456 Bohr).</p>\n", "default_value": "1.88972612456"}, {"fullname": "pyfock.Data.Data.shell_dict", "modulename": "pyfock.Data", "qualname": "Data.shell_dict", "kind": "variable", "doc": "<p>Mapping of orbital angular momentum shell labels to integer quantum numbers (e.g., 's' \u2192 1, 'p' \u2192 2, etc.).</p>\n", "default_value": "{&#x27;s&#x27;: 1, &#x27;p&#x27;: 2, &#x27;d&#x27;: 3, &#x27;f&#x27;: 4, &#x27;g&#x27;: 5, &#x27;h&#x27;: 6, &#x27;i&#x27;: 7, &#x27;j&#x27;: 8}"}, {"fullname": "pyfock.Data.Data.shell_lmn", "modulename": "pyfock.Data", "qualname": "Data.shell_lmn", "kind": "variable", "doc": "<p>Dictionary mapping Cartesian Gaussian orbital labels to their exponent tuples [lx, ly, lz] (PySCF/HORTON ordering).</p>\n", "default_value": "{&#x27;s&#x27;: [0, 0, 0], &#x27;px&#x27;: [1, 0, 0], &#x27;py&#x27;: [0, 1, 0], &#x27;pz&#x27;: [0, 0, 1], &#x27;dxx&#x27;: [2, 0, 0], &#x27;dxy&#x27;: [1, 1, 0], &#x27;dxz&#x27;: [1, 0, 1], &#x27;dyy&#x27;: [0, 2, 0], &#x27;dyz&#x27;: [0, 1, 1], &#x27;dzz&#x27;: [0, 0, 2], &#x27;fxxx&#x27;: [3, 0, 0], &#x27;fxxy&#x27;: [2, 1, 0], &#x27;fxxz&#x27;: [2, 0, 1], &#x27;fxyy&#x27;: [1, 2, 0], &#x27;fxyz&#x27;: [1, 1, 1], &#x27;fxzz&#x27;: [1, 0, 2], &#x27;fyyy&#x27;: [0, 3, 0], &#x27;fyyz&#x27;: [0, 2, 1], &#x27;fyzz&#x27;: [0, 1, 2], &#x27;fzzz&#x27;: [0, 0, 3], &#x27;gxxxx&#x27;: [4, 0, 0], &#x27;gxxxy&#x27;: [3, 1, 0], &#x27;gxxxz&#x27;: [3, 0, 1], &#x27;gxxyy&#x27;: [2, 2, 0], &#x27;gxxyz&#x27;: [2, 1, 1], &#x27;gxxzz&#x27;: [2, 0, 2], &#x27;gxyyy&#x27;: [1, 3, 0], &#x27;gxyyz&#x27;: [1, 2, 1], &#x27;gxyzz&#x27;: [1, 1, 2], &#x27;gxzzz&#x27;: [1, 0, 3], &#x27;gyyyy&#x27;: [0, 4, 0], &#x27;gyyyz&#x27;: [0, 3, 1], &#x27;gyyzz&#x27;: [0, 2, 2], &#x27;gyzzz&#x27;: [0, 1, 3], &#x27;gzzzz&#x27;: [0, 0, 4], &#x27;hxxxxx&#x27;: [5, 0, 0], &#x27;hxxxxy&#x27;: [4, 1, 0], &#x27;hxxxxz&#x27;: [4, 0, 1], &#x27;hxxxyy&#x27;: [3, 2, 0], &#x27;hxxxyz&#x27;: [3, 1, 1], &#x27;hxxxzz&#x27;: [3, 0, 2], &#x27;hxxyyy&#x27;: [2, 3, 0], &#x27;hxxyyz&#x27;: [2, 2, 1], &#x27;hxxyzz&#x27;: [2, 1, 2], &#x27;hxxzzz&#x27;: [2, 0, 3], &#x27;hxyyyy&#x27;: [1, 4, 0], &#x27;hxyyyz&#x27;: [1, 3, 1], &#x27;hxyyzz&#x27;: [1, 2, 2], &#x27;hxyzzz&#x27;: [1, 1, 3], &#x27;hxzzzz&#x27;: [1, 0, 4], &#x27;hyyyyy&#x27;: [0, 5, 0], &#x27;hyyyyz&#x27;: [0, 4, 1], &#x27;hyyyzz&#x27;: [0, 3, 2], &#x27;hyyzzz&#x27;: [0, 2, 3], &#x27;hyzzzz&#x27;: [0, 1, 4], &#x27;hzzzzz&#x27;: [0, 0, 5], &#x27;ixxxxxx&#x27;: [6, 0, 0], &#x27;ixxxxxy&#x27;: [5, 1, 0], &#x27;ixxxxxz&#x27;: [5, 0, 1], &#x27;ixxxxyy&#x27;: [4, 2, 0], &#x27;ixxxxyz&#x27;: [4, 1, 1], &#x27;ixxxxzz&#x27;: [4, 0, 2], &#x27;ixxxyyy&#x27;: [3, 3, 0], &#x27;ixxxyyz&#x27;: [3, 2, 1], &#x27;ixxxyzz&#x27;: [3, 1, 2], &#x27;ixxxzzz&#x27;: [3, 0, 3], &#x27;ixxyyyy&#x27;: [2, 4, 0], &#x27;ixxyyyz&#x27;: [2, 3, 1], &#x27;ixxyyzz&#x27;: [2, 2, 2], &#x27;ixxyzzz&#x27;: [2, 1, 3], &#x27;ixxzzzz&#x27;: [2, 0, 4], &#x27;ixyyyyy&#x27;: [1, 5, 0], &#x27;ixyyyyz&#x27;: [1, 4, 1], &#x27;ixyyyzz&#x27;: [1, 3, 2], &#x27;ixyyzzz&#x27;: [1, 2, 3], &#x27;ixyzzzz&#x27;: [1, 1, 4], &#x27;ixzzzzz&#x27;: [1, 0, 5], &#x27;iyyyyyy&#x27;: [0, 6, 0], &#x27;iyyyyyz&#x27;: [0, 5, 1], &#x27;iyyyyzz&#x27;: [0, 4, 2], &#x27;iyyyzzz&#x27;: [0, 3, 3], &#x27;iyyzzzz&#x27;: [0, 2, 4], &#x27;iyzzzzz&#x27;: [0, 1, 5], &#x27;izzzzzz&#x27;: [0, 0, 6]}"}, {"fullname": "pyfock.Data.Data.shell_lmn_tmole", "modulename": "pyfock.Data", "qualname": "Data.shell_lmn_tmole", "kind": "variable", "doc": "<p>Same as <code>shell_lmn</code>, but with the Cartesian basis ordering used in TURBOMOLE.</p>\n", "default_value": "{&#x27;s&#x27;: [0, 0, 0], &#x27;px&#x27;: [1, 0, 0], &#x27;py&#x27;: [0, 1, 0], &#x27;pz&#x27;: [0, 0, 1], &#x27;dxx&#x27;: [2, 0, 0], &#x27;dyy&#x27;: [0, 2, 0], &#x27;dzz&#x27;: [0, 0, 2], &#x27;dxy&#x27;: [1, 1, 0], &#x27;dxz&#x27;: [1, 0, 1], &#x27;dyz&#x27;: [0, 1, 1], &#x27;fxxx&#x27;: [3, 0, 0], &#x27;fxxy&#x27;: [2, 1, 0], &#x27;fxxz&#x27;: [2, 0, 1], &#x27;fxyy&#x27;: [1, 2, 0], &#x27;fxyz&#x27;: [1, 1, 1], &#x27;fxzz&#x27;: [1, 0, 2], &#x27;fyyy&#x27;: [0, 3, 0], &#x27;fyyz&#x27;: [0, 2, 1], &#x27;fyzz&#x27;: [0, 1, 2], &#x27;fzzz&#x27;: [0, 0, 3], &#x27;gxxxx&#x27;: [4, 0, 0], &#x27;gxxxy&#x27;: [3, 1, 0], &#x27;gxxxz&#x27;: [3, 0, 1], &#x27;gxxyy&#x27;: [2, 2, 0], &#x27;gxxyz&#x27;: [2, 1, 1], &#x27;gxxzz&#x27;: [2, 0, 2], &#x27;gxyyy&#x27;: [1, 3, 0], &#x27;gxyyz&#x27;: [1, 2, 1], &#x27;gxyzz&#x27;: [1, 1, 2], &#x27;gxzzz&#x27;: [1, 0, 3], &#x27;gyyyy&#x27;: [0, 4, 0], &#x27;gyyyz&#x27;: [0, 3, 1], &#x27;gyyzz&#x27;: [0, 2, 2], &#x27;gyzzz&#x27;: [0, 1, 3], &#x27;gzzzz&#x27;: [0, 0, 4]}"}, {"fullname": "pyfock.Data.Data.shell_lmn_offset", "modulename": "pyfock.Data", "qualname": "Data.shell_lmn_offset", "kind": "variable", "doc": "<p>Offsets for indexing Cartesian basis function blocks for increasing angular momentum (used for shell loops).</p>\n", "default_value": "[0, 1, 4, 10, 20, 35, 56, 84]"}, {"fullname": "pyfock.Data.Data.shell_degen", "modulename": "pyfock.Data", "qualname": "Data.shell_degen", "kind": "variable", "doc": "<p>Degeneracy (number of basis functions) of Cartesian shells as a function of angular momentum.</p>\n", "default_value": "[1, 3, 6, 10, 15, 21, 28, 36]"}, {"fullname": "pyfock.Data.Data.elementPeriod", "modulename": "pyfock.Data", "qualname": "Data.elementPeriod", "kind": "variable", "doc": "<p>Period (row) of the periodic table for each element. Index 0 corresponds to the ghost atom.</p>\n", "default_value": "[&#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;, &#x27;7&#x27;]"}, {"fullname": "pyfock.Graphics", "modulename": "pyfock.Graphics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Graphics.zoom_factor", "modulename": "pyfock.Graphics", "qualname": "zoom_factor", "kind": "variable", "doc": "<p></p>\n", "default_value": "1.0"}, {"fullname": "pyfock.Graphics.initializeGlobalVars", "modulename": "pyfock.Graphics", "qualname": "initializeGlobalVars", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.calculateBonds", "modulename": "pyfock.Graphics", "qualname": "calculateBonds", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.update_projection", "modulename": "pyfock.Graphics", "qualname": "update_projection", "kind": "function", "doc": "<p>Update the projection matrix based on current zoom factor</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.zoom_in", "modulename": "pyfock.Graphics", "qualname": "zoom_in", "kind": "function", "doc": "<p>Zoom in function</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.zoom_out", "modulename": "pyfock.Graphics", "qualname": "zoom_out", "kind": "function", "doc": "<p>Zoom out function</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.mouse_wheel", "modulename": "pyfock.Graphics", "qualname": "mouse_wheel", "kind": "function", "doc": "<p>Handle mouse wheel for zooming</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">wheel</span>, </span><span class=\"param\"><span class=\"n\">direction</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.draw_sphere", "modulename": "pyfock.Graphics", "qualname": "draw_sphere", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xyz</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">color</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.cylinder_between", "modulename": "pyfock.Graphics", "qualname": "cylinder_between", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span>, </span><span class=\"param\"><span class=\"n\">y1</span>, </span><span class=\"param\"><span class=\"n\">z1</span>, </span><span class=\"param\"><span class=\"n\">x2</span>, </span><span class=\"param\"><span class=\"n\">y2</span>, </span><span class=\"param\"><span class=\"n\">z2</span>, </span><span class=\"param\"><span class=\"n\">length</span>, </span><span class=\"param\"><span class=\"n\">radius</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.display", "modulename": "pyfock.Graphics", "qualname": "display", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.mouse_click", "modulename": "pyfock.Graphics", "qualname": "mouse_click", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">button</span>, </span><span class=\"param\"><span class=\"n\">state</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.mouse_motion", "modulename": "pyfock.Graphics", "qualname": "mouse_motion", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.keyboard", "modulename": "pyfock.Graphics", "qualname": "keyboard", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.special_keys", "modulename": "pyfock.Graphics", "qualname": "special_keys", "kind": "function", "doc": "<p>Handle special keys like Page Up/Down for zooming</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Graphics.visualize", "modulename": "pyfock.Graphics", "qualname": "visualize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;PyFock | CrysX - 3D Viewer&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Grids", "modulename": "pyfock.Grids", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Grids.Grids", "modulename": "pyfock.Grids", "qualname": "Grids", "kind": "class", "doc": "<p>Class for generating molecular integration grids for DFT and other quantum chemistry calculations.</p>\n\n<p>This class uses the <code>numgrid</code> library to generate atom-centered grids composed of:</p>\n\n<ol>\n<li>A <code>level</code> indicating the fineness of the grid (from 3 to 8, with 0 reserved internally).</li>\n<li><code>coords</code>: a (N, 3) NumPy array of Cartesian coordinates (in Bohrs) for the N grid points.</li>\n<li><code>weights</code>: a NumPy array of length N containing the integration weights for each grid point.</li>\n</ol>\n\n<p>Grid density depends not only on the level but also on the basis set and the radial precision,\nmaking it more flexible and customizable than typical grid generation schemes.</p>\n"}, {"fullname": "pyfock.Grids.Grids.__init__", "modulename": "pyfock.Grids", "qualname": "Grids.__init__", "kind": "function", "doc": "<p>Initialize a Grids object for molecular numerical integration using atom-centered grids.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mol : object\n    A Mol object containing atomic coordinates (<code>mol.coordsBohrs</code>) and nuclear charges (<code>mol.Zcharges</code>).\n    Required for placing atom-centered grid points.</p>\n\n<p>basis : object or None\n    A Basis object specifying the basis set to use. If None, defaults to 'def2-QZVPP'.\n    Affects the radial distribution of the grid.</p>\n\n<p>level : int, default=3\n    Grid resolution level. Valid values are 3 (coarse) to 8 (fine).\n    Internally mapped to a min/max angular point scheme used by the <code>numgrid</code> library.</p>\n\n<p>radial_precision : float, default=1.0e-13\n    Precision used in radial grid generation. Lower values increase the number of radial points.</p>\n\n<p>ncores : int, optional\n    Number of CPU cores to use for parallel grid generation. Defaults to the number of available cores.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>mol</code> is None or <code>level</code> is outside the supported range [3, 8].</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Uses the <code>numgrid</code> library for generating atomic-centered numerical integration grids.\nThe final grid coordinates and weights are stored in the <code>coords</code> and <code>weights</code> attributes, respectively.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">basis</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"n\">radial_precision</span><span class=\"o\">=</span><span class=\"mf\">1e-13</span>, </span><span class=\"param\"><span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">10</span></span>)</span>"}, {"fullname": "pyfock.Grids.Grids.level", "modulename": "pyfock.Grids", "qualname": "Grids.level", "kind": "variable", "doc": "<p>The chosen grid level (integer between 3 and 8). Controls the angular resolution and density of the integration grid.</p>\n"}, {"fullname": "pyfock.Grids.Grids.coords", "modulename": "pyfock.Grids", "qualname": "Grids.coords", "kind": "variable", "doc": "<p>A NumPy array of shape (N, 3), storing the Cartesian coordinates of N grid points (in Bohrs).</p>\n"}, {"fullname": "pyfock.Grids.Grids.weights", "modulename": "pyfock.Grids", "qualname": "Grids.weights", "kind": "variable", "doc": "<p>A NumPy array of length N, storing the quadrature weights corresponding to each grid point.</p>\n"}, {"fullname": "pyfock.Integrals", "modulename": "pyfock.Integrals", "kind": "module", "doc": "<p>This submodule provides highly optimized and symmetry-aware routines for \nevaluating all essential one-electron and two-electron integrals needed in \nelectronic structure calculations. The integrals are computed over Gaussian \ntype orbitals (GTOs), and both CPU (NumPy) and GPU (CuPy) implementations are \navailable for many routines to accelerate quantum chemistry workflows.</p>\n\n<h2 id=\"included-modules-and-functionality\">Included modules and functionality:</h2>\n\n<ul>\n<li>One-electron integrals:\n<ul>\n<li>Overlap integrals</li>\n<li>Kinetic energy integrals</li>\n<li>Nuclear attraction integrals</li>\n<li>Dipole moment integrals</li>\n<li>Gradients of one-electron integrals</li>\n</ul></li>\n<li>Two-electron integrals:\n<ul>\n<li>Full 4-center two electron repulsion integrals using Rys quadrature</li>\n<li>3-center and 2-center two electron integrals for density fitting</li>\n<li>Schwarz screening utilities for integral pruning</li>\n</ul></li>\n<li>Exchange-correlation evaluation routines compatible with numerical grids</li>\n<li>GPU-accelerated (CuPy) versions for key performance-critical routines</li>\n<li>Modular helper functions for computing factorials, boys functions, contraction coefficients, etc.</li>\n</ul>\n\n<h2 id=\"usage\">Usage:</h2>\n\n<p>Example:\n    from pyfock.Integrals import overlap_mat_symm\n    S = overlap_mat_symm(basis)</p>\n"}, {"fullname": "pyfock.Integrals.mmd_nuc_mat_symm", "modulename": "pyfock.Integrals", "qualname": "mmd_nuc_mat_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm", "modulename": "pyfock.Integrals", "qualname": "nuc_mat_symm", "kind": "function", "doc": "<p>Compute the nuclear attraction matrix for a given basis and molecular geometry.</p>\n\n<p>This function evaluates the one-electron nuclear attraction integrals \n\u27e8\u03c7_i | V_nuc | \u03c7_j\u27e9, where V_nuc is the Coulombic potential from the atomic nuclei.\nThe integrals are computed between all basis functions defined in <code>basis</code> and \nand the nuclei within the <code>mol</code> object.\nSo in principle, it can be used to compute the nuclear potential matrix due to the\nnuclei in one molecule, in the basis of another molecule.</p>\n\n<p>Efficient Numba-accelerated routines are used to improve performance. \nA partial block of the matrix can be computed by specifying a <code>slice</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object with fields including:\n    - bfs_coords: Cartesian coordinates of basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Normalization constants for primitives.\n    - bfs_contr_prim_norms: Normalization constants for contracted functions.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Number of atomic orbitals (contracted basis functions).</p>\n\n<p>mol : object\n    Molecule object containing:\n    - coordsBohrs: Cartesian coordinates of nuclei (in Bohr).\n    - Zcharges: Nuclear charges.\n    - natoms: Number of atoms.</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> defining \n    the sub-block of the matrix to compute. Rows and columns refer to AOs.\n    If <code>None</code> (default), the entire nuclear attraction matrix is computed.</p>\n\n<p>sqrt_ints4c2e_diag : ndarray, optional\n    Optional Schwarz screening preconditioner.\n    If provided, Schwarz screening is enabled to skip insignificant integrals.\n    If <code>None</code> (default), all integrals are computed without screening.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>V : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of nuclear attraction integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The integrals are evaluated using standard expressions over contracted Gaussians.\nIf Schwarz screening is used (<code>sqrt_ints4c2e_diag</code> is not None), a threshold-based \npruning is applied using precomputed upper bounds.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V_block</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V_schwarz</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"n\">sqrt_diag</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm", "modulename": "pyfock.Integrals", "qualname": "kin_mat_symm", "kind": "function", "doc": "<p>Compute the kinetic energy matrix for a given basis set.</p>\n\n<p>This function evaluates the one-electron kinetic energy integrals \n\u27e8\u03c7_i | -\u00bd\u2207\u00b2 | \u03c7_j\u27e9 for a set of contracted Gaussian basis functions defined in <code>basis</code>. \nIt uses an optimized backend with improved memory layout, early termination, \nand partial vectorization for enhanced performance.</p>\n\n<p>Block-wise computation is supported through the optional <code>slice</code> parameter.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing properties such as:\n    - bfs_coords: Cartesian coordinates of basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Normalization constants for primitives.\n    - bfs_contr_prim_norms: Normalization constants for contracted functions.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Number of atomic orbitals (contracted basis functions).</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> specifying the \n    matrix block to compute. Rows and columns refer to AOs. If <code>None</code> (default), \n    the entire kinetic energy matrix is calculated.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>T : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of kinetic energy integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Internally, this function:</p>\n\n<ul>\n<li>Pads coefficient/exponent arrays for uniform shape and Numba compatibility.</li>\n<li>Reduces redundant operations and loops.</li>\n<li>Utilizes an optimized <code>kin_mat_symm_internal_optimized</code> backend.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">kin_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T_block</span> <span class=\"o\">=</span> <span class=\"n\">kin_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm", "modulename": "pyfock.Integrals", "qualname": "overlap_mat_symm", "kind": "function", "doc": "<p>Compute the overlap matrix for a given basis set using symmetry-aware integrals.</p>\n\n<p>This function evaluates the overlap integrals \u27e8\u03c7_i | \u03c7_j\u27e9 between all pairs \nof basis functions defined in the <code>basis</code> object. It supports partial evaluation \nof the overlap matrix by specifying a slice.</p>\n\n<p>The integrals are computed using an efficient Numba-accelerated backend that \nbenefits from parallelization via <code>prange</code> and preprocessed NumPy arrays.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    A basis set object that contains information about basis functions, such as:\n    - bfs_coords: Cartesian coordinates of the basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Primitive normalization constants.\n    - bfs_contr_prim_norms: Contraction normalization factors.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Total number of atomic orbitals.</p>\n\n<p>slice : list of int, optional\n    A 4-element list specifying a sub-block of the matrix to compute:\n    [start_row, end_row, start_col, end_col].\n    If None (default), the full overlap matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>S : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of overlap integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is optimized for performance using preallocated NumPy arrays\nand avoids nested Python lists which are not supported efficiently by Numba.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S_block</span> <span class=\"o\">=</span> <span class=\"n\">overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_4c2e_symm", "modulename": "pyfock.Integrals", "qualname": "conv_4c2e_symm", "kind": "function", "doc": "<p>Compute four-center two-electron (4c2e) electron repulsion integrals (ERIs)\nusing the conventional and slow (analytical) formula-based method with full symmetry exploitation.</p>\n\n<p>This function evaluates integrals of the form (A B | C D), where\nA, B, C, D are basis functions from the same primary basis set.</p>\n\n<p>The \"conv\" variant uses explicit analytical integral formulas and\nnested loops over primitive Gaussians, following the derivations in:</p>\n\n<pre><code>J. Chem. Educ. 2018, 95, 9, 1572\u20131578\nhttps://pubs.acs.org/doi/full/10.1021/acs.jchemed.8b00255\n</code></pre>\n\n<p>Compared to Rys quadrature, this conventional approach is much more\ncomputationally expensive but exact for the given formula set, making\nit useful for validation and special-purpose computations.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>For 4c2e integrals, the full 8-fold permutational symmetry is used:</p>\n\n<pre><code>(A B | C D) = (B A | C D) = (A B | D C) = (B A | D C)\n            = (C D | A B) = (D C | A B) = (C D | B A) = (D C | B A)\n</code></pre>\n\n<p>This reduces the number of independent integrals from:\n    N_bf^4   \u2192   N_bf<em>(N_bf+1)/2 * N_bf</em>(N_bf+1)/2\nwhen computing the full tensor.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Total number of atomic orbitals</p>\n\n<p>slice : list of int, optional\n    An 8-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C, start_D, end_D]\n    If None (default), computes the full (Nbf, Nbf, Nbf, Nbf) tensor.</p>\n\n<pre><code>**Note:** When slices are used, symmetry exploitation is restricted\nto permutations that lie entirely within the specified slice.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints4c2e : ndarray\n    The computed 4-center 2-electron integrals for the requested range.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>All basis set data are pre-packed into NumPy arrays for Numba acceleration.</li>\n<li>Uses explicit primitive Gaussian formula evaluation without numerical quadrature.</li>\n<li>Symmetry exploitation is maximal only for full-range computations.</li>\n<li>Conventional evaluation scales as O(N_bf^4) without symmetry, but\nsymmetry reduces the number of computations drastically.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">conv_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">conv_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_4c2e_symm", "modulename": "pyfock.Integrals", "qualname": "mmd_4c2e_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm", "modulename": "pyfock.Integrals", "qualname": "rys_4c2e_symm", "kind": "function", "doc": "<p>Compute four-center two-electron (4c2e) electron repulsion integrals (ERIs) \nusing the Rys quadrature method with exploitation of 8-fold permutational \nsymmetry.</p>\n\n<p>This function evaluates integrals of the form (A B | C D), where A, B, C, D \nare basis functions from the same primary basis set. It uses Numba-accelerated \nbackends and symmetry-aware optimizations to reduce computational cost.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>The 4c2e integrals obey the following permutational symmetry relations:</p>\n\n<pre><code>(A B | C D) = (B A | C D)   # exchange within bra\n            = (A B | D C)  # exchange within ket\n            = (B A | D C)  \n            = (C D | A B)  # bra \u2194 ket exchange\n            = (D C | A B)\n            = (C D | B A)\n            = (D C | B A)\n</code></pre>\n\n<p>These 8 equivalent permutations mean that only a subset of integrals \nneeds to be explicitly computed; the rest can be obtained by symmetry.</p>\n\n<p>This reduces the number of independent integrals from:\n    N_bf^4   \u2192   N_bf<em>(N_bf+1)/2 * N_bf</em>(N_bf+1)/2\nwhen computing the full tensor.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_shell_index : Index of the shell each basis function belongs to.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>slice : list of int, optional\n    An 8-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C, start_D, end_D]\n    If None (default), computes the full (Nbf, Nbf, Nbf, Nbf) block.</p>\n\n<pre><code>**Note:** When slices are used, not all 8-fold symmetries may be \navailable because the requested block may not contain all \nsymmetric permutations. In such cases, only the applicable \nsymmetries are used.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints4c2e : ndarray\n    The computed 4-center 2-electron integrals for the requested range.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Precomputes and stores basis set data in NumPy arrays for Numba efficiency.</li>\n<li>Exploits all possible symmetry permutations when the full tensor is \ncomputed (no slice) to reduce redundant work.</li>\n<li>If a slice is specified, symmetry exploitation is limited to the \npermutations that fall within the slice's index ranges.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">rys_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">rys_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm_old", "modulename": "pyfock.Integrals", "qualname": "rys_4c2e_symm_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_3c2e_symm", "modulename": "pyfock.Integrals", "qualname": "conv_3c2e_symm", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals (ERIs)\nusing the conventional and slow (analytical) formula-based method with symmetry exploitation.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where:\n    - A and B are primary basis functions from <code>basis</code>\n    - C is an auxiliary basis function from <code>auxbasis</code></p>\n\n<p>The \"conv\" variant uses explicit analytical integral formulas and nested\nloops over primitive Gaussians, following the derivations in:</p>\n\n<pre><code>J. Chem. Educ. 2018, 95, 9, 1572\u20131578\nhttps://pubs.acs.org/doi/full/10.1021/acs.jchemed.8b00255\n</code></pre>\n\n<p>Compared to the Rys quadrature method, this conventional approach is\nsignificantly more computationally expensive, but can be useful for\nvalidation or when Rys is not applicable.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>For 3c2e integrals, the following bra symmetry is used:</p>\n\n<pre><code>(A B | C) = (B A | C)\n</code></pre>\n\n<p>This reduces the number of computed integrals from N_bf\u00b2 * N_aux\nto N_bf*(N_bf+1)/2 * N_aux when the full tensor is computed.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Total number of atomic orbitals</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>.</p>\n\n<p>slice : list of int, optional\n    A 6-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C]\n    If None (default), computes the full (Nbf, Nbf, Naux) tensor.</p>\n\n<pre><code>**Note:** When slices are used, AB symmetry exploitation is limited\nto permutations that lie entirely within the specified slice.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray\n    The computed 3-center 2-electron integrals for the requested range.\n    Shape: (Nbf, Nbf, Nauxbf) or \n    (end_A - start_A, end_B - start_B, end_C - start_C) \n    if slice is given.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>All basis set data are pre-packed into NumPy arrays for Numba acceleration.</li>\n<li>Uses explicit primitive Gaussian formula evaluation without numerical quadrature.</li>\n<li>Symmetry exploitation is maximal only for full-range computations.</li>\n<li>Conventional evaluation scales poorly compared to Rys quadrature, but is\nexact for the given formula set.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">conv_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">conv_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm", "modulename": "pyfock.Integrals", "qualname": "rys_3c2e_symm", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals using\nthe Rys quadrature method with symmetry considerations.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where A and B are\nbasis functions from a primary basis set and C is from an auxiliary basis set.\nSymmetry in the first two indices is exploited ((A B | C) = (B A | C)),\nso only the upper-triangular part of the (A,B) block is computed and the (B A | C)\nintegrals are formed by symmetry.\nThe implementation uses Numba-accelerated backends with symmetry-aware\noptimizations and optional Schwarz screening to skip negligible contributions.\nSymmetry is utilized to only compute N_{bf}*(N_{bf}+1)/2*N_{auxbf}</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing information about atomic orbitals, such as:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>, \n    but typically used for resolution-of-the-identity (RI) expansions.</p>\n\n<p>slice : list of int, optional\n    A 6-element list specifying a subset of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C]\n    If None (default), computes all N_{bf}*N_{bf}*N_{auxbf} integrals.</p>\n\n<p>schwarz : bool, optional\n    If True, applies Schwarz screening to skip calculations where the \n    product of integral bounds is below <code>schwarz_threshold</code>.</p>\n\n<p>schwarz_threshold : float, optional\n    The threshold for Schwarz screening (default is 1e-9).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray of shape \n    (Nbf, Nbf, Nauxbf) or \n    (end_A - start_A, end_B - start_B, end_C - start_C) \n    if slice is given.\n    The computed 3-center 2-electron integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Uses preallocated NumPy arrays to store primitive data for efficient Numba processing.</li>\n<li>Handles irregular contraction patterns by padding primitive arrays to the \nsize of the largest contraction.</li>\n<li>If Schwarz screening is enabled, precomputes diagonal two-electron integrals \nand uses their square roots for screening.</li>\n<li>Symmetry relations are exploited to avoid redundant calculations.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_block</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_screened</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_2c2e_symm", "modulename": "pyfock.Integrals", "qualname": "conv_2c2e_symm", "kind": "function", "doc": "<p>Compute two-center two-electron integrals (2c2e) using the conventional (slow) method,\nexploiting permutation symmetry.</p>\n\n<p>This function computes 2c2e electron repulsion integrals (ERIs) over a given\nbasis set using the conventional algorithm which is very slow compared to Rys quadrature. \nIt supports symmetric integral evaluation and allows slicing the full ERI matrix into \nblocks for efficient parallelization or chunked computation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function information such as:\n    coordinates, exponents, coefficients, angular momentum, normalization factors,\n    and number of primitives.</p>\n\n<p>slice : list of int, optional\n    A list of four integers [start_row, end_row, start_col, end_col] specifying\n    a block (subset) of the full integral matrix to compute.\n    If not provided, the full matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints2c2e : np.ndarray\n    A 2D numpy array containing the computed 2c2e integrals for the specified slice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm", "modulename": "pyfock.Integrals", "qualname": "rys_2c2e_symm", "kind": "function", "doc": "<p>Compute symmetric two-center two-electron integrals using Rys quadrature.</p>\n\n<p>This function evaluates the electron repulsion integrals (ERIs)\ninvolving only two centers (2c2e), using the Rys quadrature method. \nThe integrals are computed efficiently using Numba, and the data is prepared \naccordingly for compatibility with JIT compilation. It assumes symmetry, \nand computes only a specified block if requested.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    A basis set object containing the basis function data. It must have attributes:\n    - bfs_coords : list of (x, y, z) coordinates of basis function centers\n    - bfs_contr_prim_norms : contraction-normalization factors\n    - bfs_lmn : angular momentum tuples (l, m, n)\n    - bfs_nprim : number of primitives for each basis function\n    - bfs_coeffs : contraction coefficients\n    - bfs_expnts : primitive exponents\n    - bfs_prim_norms : primitive normalization constants\n    - bfs_nao : total number of atomic orbitals (basis functions)</p>\n\n<p>slice : list of int, optional\n    A four-element list <code>[start_row, end_row, start_col, end_col]</code> specifying the \n    row and column ranges of the matrix to be computed. If None, the full matrix \n    is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints2c2e : ndarray\n    A 2D numpy array of shape <code>(end_row - start_row, end_col - start_col)</code> \n    containing the computed symmetric two-center two-electron integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function prepares the basis set data in a Numba-friendly format by \nconverting ragged lists into padded 2D arrays, where the second dimension \ncorresponds to the maximum number of primitives. The core integral computation \nis offloaded to a Numba-accelerated function <code>rys_2c2e_symm_internal</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_tri", "modulename": "pyfock.Integrals", "qualname": "rys_3c2e_tri", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals using\nthe Rys quadrature method with symmetry considerations, stored in packed\ntriangular form for memory efficiency.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where A and B are\nbasis functions from a primary basis set and C is from an auxiliary basis set.\nSymmetry in the first two indices is exploited ((A B | C) = (B A | C)),\nso only the upper-triangular part of the (A,B) block is computed and stored.\nThe resulting array has shape (N_{bf}*(N_{bf}+1)/2, N_{auxbf}), where the first\nindex corresponds to a flattened 1D triangular index over basis function pairs.</p>\n\n<p>Unlike <code>rys_3c2e_symm</code>, this routine does not support computing arbitrary slices\n\u2014 the full triangular set is always evaluated.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing information about atomic orbitals, such as:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>,\n    typically used for resolution-of-the-identity (RI) expansions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray of shape (Nbf*(Nbf+1)//2, Nauxbf)\n    The computed 3-center 2-electron integrals in packed triangular form.\n    The mapping from a pair (i, j) with i \u2264 j to the first dimension index\n    follows standard upper-triangular packing order.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This is a memory-efficient variant of <code>rys_3c2e_symm</code> that avoids storing\nthe full (Nbf, Nbf, Nauxbf) array.</li>\n<li>Uses preallocated NumPy arrays for primitive data to ensure efficient Numba processing.</li>\n<li>Handles irregular contraction patterns by padding primitive arrays to the size\nof the largest contraction in the set.</li>\n<li>No Schwarz screening or partial computation is available in this function.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_tri</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_tri</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Retrieve value for pair (i, j) and auxiliary k:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">packed_index</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">Nbf</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">j</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">i</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"n\">Nbf</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">ints_tri</span><span class=\"p\">[</span><span class=\"n\">packed_index</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">bfs_nao</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_nuc_mat_symm", "modulename": "pyfock.Integrals", "qualname": "rys_nuc_mat_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_tri_schwarzbf_val_helpers", "modulename": "pyfock.Integrals", "qualname": "rys_3c2e_tri_schwarzbf_val_helpers", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_1", "modulename": "pyfock.Integrals", "qualname": "eval_xc_1", "kind": "function", "doc": "<p>Evaluate exchange-correlation (XC) energy and potential matrix for DFT\nusing algorithm 1, which is a baseline method for grid-based DFT.</p>\n\n<p>In algorithm 1, the XC term is evaluated by looping over blocks of grid \npoints, and within each block, the operations are parallelized. This \napproach is functional but generally slower than algorithm 2 for CPU-based \nexecution.</p>\n\n<p>This function evaluates the XC energy and potential matrix elements for a given\ndensity matrix using numerical integration over a 3D real-space grid. It supports \nLDA and GGA functionals via LibXC and optional use of precomputed AO values and \ngradients for performance gains. Sparse AO matrix techniques are also supported.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function data: exponents, coefficients, \n    angular momentum, normalization, and other AO metadata.</p>\n\n<p>dmat : np.ndarray\n    The one-electron density matrix in the AO basis.</p>\n\n<p>weights : np.ndarray\n    Integration weights associated with each grid point.</p>\n\n<p>coords : np.ndarray\n    Grid point coordinates as an (N, 3) array.</p>\n\n<p>funcid : list of int, optional\n    LibXC functional IDs. Default is [1, 7] for Slater (X) and VWN (C) (LDA).</p>\n\n<p>spin : int, optional\n    Spin multiplicity: 0 for unpolarized. Spin-polarized (1) not currently supported.</p>\n\n<p>blocksize : int, optional\n    Number of grid points to process per block. Default is 50000.</p>\n\n<p>debug : bool, optional\n    If True, enables verbose timing and diagnostic output.</p>\n\n<p>list_nonzero_indices : list of np.ndarray, optional\n    List of AO indices with non-negligible contributions in each grid block\n    for sparse matrix optimizations.</p>\n\n<p>count_nonzero_indices : list of int, optional\n    Number of significant AO indices per block; matches entries in <code>list_nonzero_indices</code>.</p>\n\n<p>list_ao_values : list of np.ndarray, optional\n    Precomputed AO values at grid points for each block.</p>\n\n<p>list_ao_grad_values : list of tuple of np.ndarray, optional\n    Precomputed AO gradient values (x, y, z) at grid points for each block.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>efunc : float\n    Total exchange-correlation energy.</p>\n\n<p>v : np.ndarray\n    Exchange-correlation potential matrix in the AO basis.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This algorithm prioritizes code clarity and correctness, not maximum speed.</li>\n<li>Only LDA and GGA functionals are currently supported. meta-GGA and hybrid functionals\nare planned for future implementation.</li>\n<li>Uses LibXC for exchange-correlation energy and potential evaluation.</li>\n<li>AO values and gradients can be reused via precomputation to improve speed.</li>\n<li>The number of electrons (via integrated density) is printed for validation.</li>\n</ul>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>LibXC Functional Codes: <a href=\"https://libxc.gitlab.io/functionals/\">https://libxc.gitlab.io/functionals/</a></li>\n<li>Functional energy and potential formulation: <a href=\"https://pubs.acs.org/doi/full/10.1021/ct200412r\">https://pubs.acs.org/doi/full/10.1021/ct200412r</a></li>\n<li>LibXC Python interface: <a href=\"https://www.tddft.org/programs/libxc/manual/\">https://www.tddft.org/programs/libxc/manual/</a></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">50000</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2", "modulename": "pyfock.Integrals", "qualname": "eval_xc_2", "kind": "function", "doc": "<p>Evaluate exchange-correlation (XC) energy and potential matrix for DFT\nusing algorithm 2, which is the preferred algorithm for running DFT on CPU.</p>\n\n<p>In algorithm 2, the XC term is evaluated by parallelizing over batches.\nIn contrast, the algorithm 1 evaluates the XC term by looping over batches and \nparallelizing the operations within the batch, which is suboptimal.</p>\n\n<p>This function evaluates the XC energy and potential matrix elements for a given\ndensity matrix using grid-based numerical integration. It supports LDA and GGA \nfunctionals (via LibXC), parallel execution with <code>joblib</code>, and sparse AO matrix blocks.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function data: exponents, coefficients, \n    angular momentum, normalization, etc.</p>\n\n<p>dmat : np.ndarray\n    The one-electron density matrix in the AO basis.</p>\n\n<p>weights : np.ndarray\n    Integration weights associated with each grid point.</p>\n\n<p>coords : np.ndarray\n    Grid point coordinates as an (N, 3) array.</p>\n\n<p>funcid : list of int, optional\n    LibXC functional IDs. Default is [1, 7] for Slater (X) and VWN (C) (LDA).</p>\n\n<p>spin : int, optional\n    Spin multiplicity: 0 for unpolarized, 1 for spin-polarized (not allowed currently).</p>\n\n<p>ncores : int, optional\n    Number of threads/cores for parallel execution. Default is 2.</p>\n\n<p>blocksize : int, optional\n    Number of grid points to process per block. Default is 5000.</p>\n\n<p>list_nonzero_indices : list of np.ndarray, optional\n    Precomputed list of nonzero AO indices per block for sparse evaluation.</p>\n\n<p>count_nonzero_indices : list of int, optional\n    Number of nonzero indices in each block (matches <code>list_nonzero_indices</code>).</p>\n\n<p>list_ao_values : list of np.ndarray, optional\n    Precomputed AO values at grid points for each block.</p>\n\n<p>list_ao_grad_values : list of tuple of np.ndarray, optional\n    Precomputed AO gradient values (x, y, z) at grid points for each block.</p>\n\n<p>debug : bool, optional\n    If True, print detailed timing and diagnostic info.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>efunc : float\n    Total exchange-correlation energy.</p>\n\n<p>v : np.ndarray\n    Exchange-correlation potential matrix in the AO basis.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Only supports LDA and GGA functionals currently. meta-GGA and hybrid support is in development.</li>\n<li>Uses LibXC for energy and derivative functional evaluation.</li>\n<li>Blocks are randomly shuffled before processing to balance parallel load.</li>\n<li>Grid-based DFT evaluation using precomputed AO and gradient matrices is supported.</li>\n</ul>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>LibXC Functional Codes: <a href=\"https://libxc.gitlab.io/functionals/\">https://libxc.gitlab.io/functionals/</a></li>\n<li>XC term evaluation inspired from: <a href=\"https://pubs.acs.org/doi/full/10.1021/ct200412r\">https://pubs.acs.org/doi/full/10.1021/ct200412r</a></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3", "modulename": "pyfock.Integrals", "qualname": "eval_xc_3", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy", "modulename": "pyfock.Integrals", "qualname": "eval_xc_1_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">50000</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_libxc</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nstreams</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ngpus</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">freemem</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">threads_per_block</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\ttype=&lt;class &#x27;numpy.float64&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2_cupy", "modulename": "pyfock.Integrals", "qualname": "eval_xc_2_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy", "modulename": "pyfock.Integrals", "qualname": "eval_xc_3_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">10240</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_libxc</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nstreams</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ngpus</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">freemem</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">threads_per_block</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\ttype=&lt;class &#x27;numpy.float64&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">streams</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nb_streams</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_data_as_np_arrays</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm", "modulename": "pyfock.Integrals", "qualname": "dipole_moment_mat_symm", "kind": "function", "doc": "<p>Compute the dipole moment integral matrix in the atomic orbital (AO) basis\nusing symmetry and the McMurchie\u2013Davidson algorithm.</p>\n\n<p>This routine evaluates the matrix elements:</p>\n\n<pre><code>\u03bc_ij^(k) = \u27e8 \u03c7_i | r_k | \u03c7_j \u27e9\n</code></pre>\n\n<p>where:\n    - \u03c7_i, \u03c7_j are Gaussian-type atomic orbitals (AOs)\n    - r_k is the k-th Cartesian coordinate (x, y, or z)\n    - origin is the coordinate origin for the dipole operator</p>\n\n<p>The implementation follows the McMurchie\u2013Davidson scheme for Gaussian\nintegrals, adapted from:</p>\n\n<pre><code>https://github.com/jjgoings/McMurchie-Davidson\n</code></pre>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>The dipole moment matrix is symmetric for real-valued AOs:</p>\n\n<pre><code>\u03bc_ij^(k) = \u03bc_ji^(k)\n</code></pre>\n\n<p>This halves the number of unique integrals from N_bf^2 to\nN_bf*(N_bf+1)/2 for each Cartesian component.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing:\n    - bfs_coords : Cartesian coordinates of AO centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Number of atomic orbitals</p>\n\n<p>slice : list of int, optional\n    A 4-element list [row_start, row_end, col_start, col_end]\n    specifying the sub-block of the matrix to compute.\n    If None (default), computes the full symmetric matrix.</p>\n\n<p>origin : ndarray of shape (3,), optional\n    Origin of the dipole operator in Cartesian coordinates.\n    Default is (0.0, 0.0, 0.0).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>M : ndarray of shape (3, n_rows, n_cols)\n    The computed dipole moment integrals for the requested block,\n    with the first dimension indexing the x, y, z components.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Basis set data are pre-packed into NumPy arrays for compatibility\nwith Numba JIT compilation.</li>\n<li>The algorithm avoids redundant evaluations by exploiting matrix\nsymmetry when <code>slice</code> covers the full range.</li>\n<li>The dipole moment integrals are typically used in computing\nmolecular dipole moments from density matrices.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_full</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_block</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_shifted</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]))</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">])</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "kin_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "overlap_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "dipole_moment_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "nuc_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy", "modulename": "pyfock.Integrals", "qualname": "kin_mat_symm_shell_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "rys_2c2e_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy", "modulename": "pyfock.Integrals", "qualname": "rys_3c2e_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "modulename": "pyfock.Integrals", "qualname": "rys_3c2e_symm_cupy_fp32", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_grad_symm", "modulename": "pyfock.Integrals", "qualname": "overlap_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_grad_symm", "modulename": "pyfock.Integrals", "qualname": "kin_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_grad_symm", "modulename": "pyfock.Integrals", "qualname": "nuc_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.cross_overlap_mat_symm", "modulename": "pyfock.Integrals", "qualname": "cross_overlap_mat_symm", "kind": "function", "doc": "<p>Compute the overlap matrix between two distinct basis sets.</p>\n\n<p>This function calculates the overlap integrals \u27e8\u03c7_i^A | \u03c7_j^B\u27e9 between basis functions \nfrom two different basis sets, <code>basisA</code> and <code>basisB</code>. It supports block-wise computation \nof the matrix to save time and memory during large-scale calculations.</p>\n\n<p>S_{\u03bc\u03bd}^{AB} = \u27e8 \u03c7_\u03bc^A | \u03c7_\u03bd^B \u27e9</p>\n\n<p>All integrals are evaluated using a Numba-accelerated backend that converts \nrequired basis set properties into NumPy arrays for efficient performance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basisA : object\n    The first basis set object containing properties such as:\n    - bfs_coords: Cartesian coordinates of centers\n    - bfs_coeffs: Contraction coefficients\n    - bfs_expnts: Gaussian exponents\n    - bfs_prim_norms: Primitive normalization constants\n    - bfs_contr_prim_norms: Contraction normalization constants\n    - bfs_lmn: Angular momentum quantum numbers\n    - bfs_nprim: Number of primitives per AO\n    - bfs_nao: Total number of atomic orbitals</p>\n\n<p>basisB : object\n    The second basis set object, structured identically to <code>basisA</code>.</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> that defines\n    a block of the full matrix to compute. Rows correspond to functions in <code>basisA</code>,\n    and columns to those in <code>basisB</code>. If <code>None</code> (default), the full matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>S : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed cross overlap (sub)matrix.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The function handles contraction and normalization internally. Since Numba does not\nsupport jagged lists, the function reshapes data into padded 2D arrays based on\nthe maximum number of primitives in either basis set.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">cross_overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basisA</span><span class=\"p\">,</span> <span class=\"n\">basisB</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S_block</span> <span class=\"o\">=</span> <span class=\"n\">cross_overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basisA</span><span class=\"p\">,</span> <span class=\"n\">basisB</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basisA</span>, </span><span class=\"param\"><span class=\"n\">basisB</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_2c2e_symm", "modulename": "pyfock.Integrals.conv_2c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.conv_2c2e_symm.conv_2c2e_symm", "modulename": "pyfock.Integrals.conv_2c2e_symm", "qualname": "conv_2c2e_symm", "kind": "function", "doc": "<p>Compute two-center two-electron integrals (2c2e) using the conventional (slow) method,\nexploiting permutation symmetry.</p>\n\n<p>This function computes 2c2e electron repulsion integrals (ERIs) over a given\nbasis set using the conventional algorithm which is very slow compared to Rys quadrature. \nIt supports symmetric integral evaluation and allows slicing the full ERI matrix into \nblocks for efficient parallelization or chunked computation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function information such as:\n    coordinates, exponents, coefficients, angular momentum, normalization factors,\n    and number of primitives.</p>\n\n<p>slice : list of int, optional\n    A list of four integers [start_row, end_row, start_col, end_col] specifying\n    a block (subset) of the full integral matrix to compute.\n    If not provided, the full matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints2c2e : np.ndarray\n    A 2D numpy array containing the computed 2c2e integrals for the specified slice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_2c2e_symm.conv_2c2e_symm_internal", "modulename": "pyfock.Integrals.conv_2c2e_symm", "qualname": "conv_2c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_3c2e_symm", "modulename": "pyfock.Integrals.conv_3c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.conv_3c2e_symm.conv_3c2e_symm", "modulename": "pyfock.Integrals.conv_3c2e_symm", "qualname": "conv_3c2e_symm", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals (ERIs)\nusing the conventional and slow (analytical) formula-based method with symmetry exploitation.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where:\n    - A and B are primary basis functions from <code>basis</code>\n    - C is an auxiliary basis function from <code>auxbasis</code></p>\n\n<p>The \"conv\" variant uses explicit analytical integral formulas and nested\nloops over primitive Gaussians, following the derivations in:</p>\n\n<pre><code>J. Chem. Educ. 2018, 95, 9, 1572\u20131578\nhttps://pubs.acs.org/doi/full/10.1021/acs.jchemed.8b00255\n</code></pre>\n\n<p>Compared to the Rys quadrature method, this conventional approach is\nsignificantly more computationally expensive, but can be useful for\nvalidation or when Rys is not applicable.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>For 3c2e integrals, the following bra symmetry is used:</p>\n\n<pre><code>(A B | C) = (B A | C)\n</code></pre>\n\n<p>This reduces the number of computed integrals from N_bf\u00b2 * N_aux\nto N_bf*(N_bf+1)/2 * N_aux when the full tensor is computed.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Total number of atomic orbitals</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>.</p>\n\n<p>slice : list of int, optional\n    A 6-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C]\n    If None (default), computes the full (Nbf, Nbf, Naux) tensor.</p>\n\n<pre><code>**Note:** When slices are used, AB symmetry exploitation is limited\nto permutations that lie entirely within the specified slice.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray\n    The computed 3-center 2-electron integrals for the requested range.\n    Shape: (Nbf, Nbf, Nauxbf) or \n    (end_A - start_A, end_B - start_B, end_C - start_C) \n    if slice is given.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>All basis set data are pre-packed into NumPy arrays for Numba acceleration.</li>\n<li>Uses explicit primitive Gaussian formula evaluation without numerical quadrature.</li>\n<li>Symmetry exploitation is maximal only for full-range computations.</li>\n<li>Conventional evaluation scales poorly compared to Rys quadrature, but is\nexact for the given formula set.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">conv_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">conv_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_3c2e_symm.conv_3c2e_symm_internal", "modulename": "pyfock.Integrals.conv_3c2e_symm", "qualname": "conv_3c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_4c2e_symm", "modulename": "pyfock.Integrals.conv_4c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.conv_4c2e_symm.conv_4c2e_symm", "modulename": "pyfock.Integrals.conv_4c2e_symm", "qualname": "conv_4c2e_symm", "kind": "function", "doc": "<p>Compute four-center two-electron (4c2e) electron repulsion integrals (ERIs)\nusing the conventional and slow (analytical) formula-based method with full symmetry exploitation.</p>\n\n<p>This function evaluates integrals of the form (A B | C D), where\nA, B, C, D are basis functions from the same primary basis set.</p>\n\n<p>The \"conv\" variant uses explicit analytical integral formulas and\nnested loops over primitive Gaussians, following the derivations in:</p>\n\n<pre><code>J. Chem. Educ. 2018, 95, 9, 1572\u20131578\nhttps://pubs.acs.org/doi/full/10.1021/acs.jchemed.8b00255\n</code></pre>\n\n<p>Compared to Rys quadrature, this conventional approach is much more\ncomputationally expensive but exact for the given formula set, making\nit useful for validation and special-purpose computations.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>For 4c2e integrals, the full 8-fold permutational symmetry is used:</p>\n\n<pre><code>(A B | C D) = (B A | C D) = (A B | D C) = (B A | D C)\n            = (C D | A B) = (D C | A B) = (C D | B A) = (D C | B A)\n</code></pre>\n\n<p>This reduces the number of independent integrals from:\n    N_bf^4   \u2192   N_bf<em>(N_bf+1)/2 * N_bf</em>(N_bf+1)/2\nwhen computing the full tensor.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Total number of atomic orbitals</p>\n\n<p>slice : list of int, optional\n    An 8-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C, start_D, end_D]\n    If None (default), computes the full (Nbf, Nbf, Nbf, Nbf) tensor.</p>\n\n<pre><code>**Note:** When slices are used, symmetry exploitation is restricted\nto permutations that lie entirely within the specified slice.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints4c2e : ndarray\n    The computed 4-center 2-electron integrals for the requested range.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>All basis set data are pre-packed into NumPy arrays for Numba acceleration.</li>\n<li>Uses explicit primitive Gaussian formula evaluation without numerical quadrature.</li>\n<li>Symmetry exploitation is maximal only for full-range computations.</li>\n<li>Conventional evaluation scales as O(N_bf^4) without symmetry, but\nsymmetry reduces the number of computations drastically.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">conv_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">conv_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.conv_4c2e_symm.conv_4c2e_symm_internal", "modulename": "pyfock.Integrals.conv_4c2e_symm", "qualname": "conv_4c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startD</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endD</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.cross_overlap_mat_symm", "modulename": "pyfock.Integrals.cross_overlap_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.cross_overlap_mat_symm.cross_overlap_mat_symm", "modulename": "pyfock.Integrals.cross_overlap_mat_symm", "qualname": "cross_overlap_mat_symm", "kind": "function", "doc": "<p>Compute the overlap matrix between two distinct basis sets.</p>\n\n<p>This function calculates the overlap integrals \u27e8\u03c7_i^A | \u03c7_j^B\u27e9 between basis functions \nfrom two different basis sets, <code>basisA</code> and <code>basisB</code>. It supports block-wise computation \nof the matrix to save time and memory during large-scale calculations.</p>\n\n<p>S_{\u03bc\u03bd}^{AB} = \u27e8 \u03c7_\u03bc^A | \u03c7_\u03bd^B \u27e9</p>\n\n<p>All integrals are evaluated using a Numba-accelerated backend that converts \nrequired basis set properties into NumPy arrays for efficient performance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basisA : object\n    The first basis set object containing properties such as:\n    - bfs_coords: Cartesian coordinates of centers\n    - bfs_coeffs: Contraction coefficients\n    - bfs_expnts: Gaussian exponents\n    - bfs_prim_norms: Primitive normalization constants\n    - bfs_contr_prim_norms: Contraction normalization constants\n    - bfs_lmn: Angular momentum quantum numbers\n    - bfs_nprim: Number of primitives per AO\n    - bfs_nao: Total number of atomic orbitals</p>\n\n<p>basisB : object\n    The second basis set object, structured identically to <code>basisA</code>.</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> that defines\n    a block of the full matrix to compute. Rows correspond to functions in <code>basisA</code>,\n    and columns to those in <code>basisB</code>. If <code>None</code> (default), the full matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>S : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed cross overlap (sub)matrix.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The function handles contraction and normalization internally. Since Numba does not\nsupport jagged lists, the function reshapes data into padded 2D arrays based on\nthe maximum number of primitives in either basis set.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">cross_overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basisA</span><span class=\"p\">,</span> <span class=\"n\">basisB</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S_block</span> <span class=\"o\">=</span> <span class=\"n\">cross_overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basisA</span><span class=\"p\">,</span> <span class=\"n\">basisB</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basisA</span>, </span><span class=\"param\"><span class=\"n\">basisB</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.cross_overlap_mat_symm.cross_overlap_mat_internal", "modulename": "pyfock.Integrals.cross_overlap_mat_symm", "qualname": "cross_overlap_mat_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfsA_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfsA_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfsB_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm", "modulename": "pyfock.Integrals.dipole_moment_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm.dipole_moment_mat_symm", "modulename": "pyfock.Integrals.dipole_moment_mat_symm", "qualname": "dipole_moment_mat_symm", "kind": "function", "doc": "<p>Compute the dipole moment integral matrix in the atomic orbital (AO) basis\nusing symmetry and the McMurchie\u2013Davidson algorithm.</p>\n\n<p>This routine evaluates the matrix elements:</p>\n\n<pre><code>\u03bc_ij^(k) = \u27e8 \u03c7_i | r_k | \u03c7_j \u27e9\n</code></pre>\n\n<p>where:\n    - \u03c7_i, \u03c7_j are Gaussian-type atomic orbitals (AOs)\n    - r_k is the k-th Cartesian coordinate (x, y, or z)\n    - origin is the coordinate origin for the dipole operator</p>\n\n<p>The implementation follows the McMurchie\u2013Davidson scheme for Gaussian\nintegrals, adapted from:</p>\n\n<pre><code>https://github.com/jjgoings/McMurchie-Davidson\n</code></pre>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>The dipole moment matrix is symmetric for real-valued AOs:</p>\n\n<pre><code>\u03bc_ij^(k) = \u03bc_ji^(k)\n</code></pre>\n\n<p>This halves the number of unique integrals from N_bf^2 to\nN_bf*(N_bf+1)/2 for each Cartesian component.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing:\n    - bfs_coords : Cartesian coordinates of AO centers\n    - bfs_coeffs : Contraction coefficients\n    - bfs_expnts : Gaussian exponents\n    - bfs_prim_norms : Primitive normalization constants\n    - bfs_contr_prim_norms : Contraction normalization factors\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n)\n    - bfs_nprim : Number of primitives per basis function\n    - bfs_nao : Number of atomic orbitals</p>\n\n<p>slice : list of int, optional\n    A 4-element list [row_start, row_end, col_start, col_end]\n    specifying the sub-block of the matrix to compute.\n    If None (default), computes the full symmetric matrix.</p>\n\n<p>origin : ndarray of shape (3,), optional\n    Origin of the dipole operator in Cartesian coordinates.\n    Default is (0.0, 0.0, 0.0).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>M : ndarray of shape (3, n_rows, n_cols)\n    The computed dipole moment integrals for the requested block,\n    with the first dimension indexing the x, y, z components.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Basis set data are pre-packed into NumPy arrays for compatibility\nwith Numba JIT compilation.</li>\n<li>The algorithm avoids redundant evaluations by exploiting matrix\nsymmetry when <code>slice</code> covers the full range.</li>\n<li>The dipole moment integrals are typically used in computing\nmolecular dipole moments from density matrices.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_full</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_block</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mu_shifted</span> <span class=\"o\">=</span> <span class=\"n\">dipole_moment_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]))</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">])</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm.dipole_moment_mat_symm_internal", "modulename": "pyfock.Integrals.dipole_moment_mat_symm", "qualname": "dipole_moment_mat_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy.dipole_moment_mat_symm_cupy", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "qualname": "dipole_moment_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy.hermite_gauss_coeff2", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "qualname": "hermite_gauss_coeff2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">Qx</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy.dipole_moment_mat_symm_internal_cuda", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "qualname": "dipole_moment_mat_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">lower_tri</span>,</span><span class=\"param\">\t<span class=\"n\">upper_tri</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_nonsymm</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.dipole_moment_mat_symm_cupy.fuse", "modulename": "pyfock.Integrals.dipole_moment_mat_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1", "modulename": "pyfock.Integrals.eval_xc_1", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_1.eval_xc_1", "modulename": "pyfock.Integrals.eval_xc_1", "qualname": "eval_xc_1", "kind": "function", "doc": "<p>Evaluate exchange-correlation (XC) energy and potential matrix for DFT\nusing algorithm 1, which is a baseline method for grid-based DFT.</p>\n\n<p>In algorithm 1, the XC term is evaluated by looping over blocks of grid \npoints, and within each block, the operations are parallelized. This \napproach is functional but generally slower than algorithm 2 for CPU-based \nexecution.</p>\n\n<p>This function evaluates the XC energy and potential matrix elements for a given\ndensity matrix using numerical integration over a 3D real-space grid. It supports \nLDA and GGA functionals via LibXC and optional use of precomputed AO values and \ngradients for performance gains. Sparse AO matrix techniques are also supported.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function data: exponents, coefficients, \n    angular momentum, normalization, and other AO metadata.</p>\n\n<p>dmat : np.ndarray\n    The one-electron density matrix in the AO basis.</p>\n\n<p>weights : np.ndarray\n    Integration weights associated with each grid point.</p>\n\n<p>coords : np.ndarray\n    Grid point coordinates as an (N, 3) array.</p>\n\n<p>funcid : list of int, optional\n    LibXC functional IDs. Default is [1, 7] for Slater (X) and VWN (C) (LDA).</p>\n\n<p>spin : int, optional\n    Spin multiplicity: 0 for unpolarized. Spin-polarized (1) not currently supported.</p>\n\n<p>blocksize : int, optional\n    Number of grid points to process per block. Default is 50000.</p>\n\n<p>debug : bool, optional\n    If True, enables verbose timing and diagnostic output.</p>\n\n<p>list_nonzero_indices : list of np.ndarray, optional\n    List of AO indices with non-negligible contributions in each grid block\n    for sparse matrix optimizations.</p>\n\n<p>count_nonzero_indices : list of int, optional\n    Number of significant AO indices per block; matches entries in <code>list_nonzero_indices</code>.</p>\n\n<p>list_ao_values : list of np.ndarray, optional\n    Precomputed AO values at grid points for each block.</p>\n\n<p>list_ao_grad_values : list of tuple of np.ndarray, optional\n    Precomputed AO gradient values (x, y, z) at grid points for each block.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>efunc : float\n    Total exchange-correlation energy.</p>\n\n<p>v : np.ndarray\n    Exchange-correlation potential matrix in the AO basis.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This algorithm prioritizes code clarity and correctness, not maximum speed.</li>\n<li>Only LDA and GGA functionals are currently supported. meta-GGA and hybrid functionals\nare planned for future implementation.</li>\n<li>Uses LibXC for exchange-correlation energy and potential evaluation.</li>\n<li>AO values and gradients can be reused via precomputation to improve speed.</li>\n<li>The number of electrons (via integrated density) is printed for validation.</li>\n</ul>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>LibXC Functional Codes: <a href=\"https://libxc.gitlab.io/functionals/\">https://libxc.gitlab.io/functionals/</a></li>\n<li>Functional energy and potential formulation: <a href=\"https://pubs.acs.org/doi/full/10.1021/ct200412r\">https://pubs.acs.org/doi/full/10.1021/ct200412r</a></li>\n<li>LibXC Python interface: <a href=\"https://www.tddft.org/programs/libxc/manual/\">https://www.tddft.org/programs/libxc/manual/</a></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">50000</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.eval_xc_1_cupy", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "eval_xc_1_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">50000</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_libxc</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nstreams</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ngpus</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">freemem</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">threads_per_block</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\ttype=&lt;class &#x27;numpy.float64&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.calc_F", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "calc_F", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weights_block</span>, </span><span class=\"param\"><span class=\"n\">v_rho_temp</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.calc_z", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "calc_z", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weights_block</span>, </span><span class=\"param\"><span class=\"n\">v_rho_temp</span>, </span><span class=\"param\"><span class=\"n\">ao_value_block</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.calc_sigma", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "calc_sigma", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho_grad_block_x</span>, </span><span class=\"param\"><span class=\"n\">rho_grad_block_y</span>, </span><span class=\"param\"><span class=\"n\">rho_grad_block_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.calc_z_gga", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "calc_z_gga", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">Fx</span>,</span><span class=\"param\">\t<span class=\"n\">Fy</span>,</span><span class=\"param\">\t<span class=\"n\">Fz</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_x</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_y</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.elementwise_multiply", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "elementwise_multiply", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_1_cupy.fuse", "modulename": "pyfock.Integrals.eval_xc_1_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2", "modulename": "pyfock.Integrals.eval_xc_2", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_2.eval_xc_2", "modulename": "pyfock.Integrals.eval_xc_2", "qualname": "eval_xc_2", "kind": "function", "doc": "<p>Evaluate exchange-correlation (XC) energy and potential matrix for DFT\nusing algorithm 2, which is the preferred algorithm for running DFT on CPU.</p>\n\n<p>In algorithm 2, the XC term is evaluated by parallelizing over batches.\nIn contrast, the algorithm 1 evaluates the XC term by looping over batches and \nparallelizing the operations within the batch, which is suboptimal.</p>\n\n<p>This function evaluates the XC energy and potential matrix elements for a given\ndensity matrix using grid-based numerical integration. It supports LDA and GGA \nfunctionals (via LibXC), parallel execution with <code>joblib</code>, and sparse AO matrix blocks.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : Basis\n    A basis object containing basis function data: exponents, coefficients, \n    angular momentum, normalization, etc.</p>\n\n<p>dmat : np.ndarray\n    The one-electron density matrix in the AO basis.</p>\n\n<p>weights : np.ndarray\n    Integration weights associated with each grid point.</p>\n\n<p>coords : np.ndarray\n    Grid point coordinates as an (N, 3) array.</p>\n\n<p>funcid : list of int, optional\n    LibXC functional IDs. Default is [1, 7] for Slater (X) and VWN (C) (LDA).</p>\n\n<p>spin : int, optional\n    Spin multiplicity: 0 for unpolarized, 1 for spin-polarized (not allowed currently).</p>\n\n<p>ncores : int, optional\n    Number of threads/cores for parallel execution. Default is 2.</p>\n\n<p>blocksize : int, optional\n    Number of grid points to process per block. Default is 5000.</p>\n\n<p>list_nonzero_indices : list of np.ndarray, optional\n    Precomputed list of nonzero AO indices per block for sparse evaluation.</p>\n\n<p>count_nonzero_indices : list of int, optional\n    Number of nonzero indices in each block (matches <code>list_nonzero_indices</code>).</p>\n\n<p>list_ao_values : list of np.ndarray, optional\n    Precomputed AO values at grid points for each block.</p>\n\n<p>list_ao_grad_values : list of tuple of np.ndarray, optional\n    Precomputed AO gradient values (x, y, z) at grid points for each block.</p>\n\n<p>debug : bool, optional\n    If True, print detailed timing and diagnostic info.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>efunc : float\n    Total exchange-correlation energy.</p>\n\n<p>v : np.ndarray\n    Exchange-correlation potential matrix in the AO basis.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Only supports LDA and GGA functionals currently. meta-GGA and hybrid support is in development.</li>\n<li>Uses LibXC for energy and derivative functional evaluation.</li>\n<li>Blocks are randomly shuffled before processing to balance parallel load.</li>\n<li>Grid-based DFT evaluation using precomputed AO and gradient matrices is supported.</li>\n</ul>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>LibXC Functional Codes: <a href=\"https://libxc.gitlab.io/functionals/\">https://libxc.gitlab.io/functionals/</a></li>\n<li>XC term evaluation inspired from: <a href=\"https://pubs.acs.org/doi/full/10.1021/ct200412r\">https://pubs.acs.org/doi/full/10.1021/ct200412r</a></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2.block_dens_func", "modulename": "pyfock.Integrals.eval_xc_2", "qualname": "block_dens_func", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">weights_block</span>,</span><span class=\"param\">\t<span class=\"n\">coords_block</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_data_as_np_arrays</span>,</span><span class=\"param\">\t<span class=\"n\">non_zero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">c_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xc_family_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">numexpr_expr</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2_cupy", "modulename": "pyfock.Integrals.eval_xc_2_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_2_cupy.eval_xc_2_cupy", "modulename": "pyfock.Integrals.eval_xc_2_cupy", "qualname": "eval_xc_2_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_2_cupy.block_dens_func", "modulename": "pyfock.Integrals.eval_xc_2_cupy", "qualname": "block_dens_func", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">weights_block</span>,</span><span class=\"param\">\t<span class=\"n\">coords_block</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_data_as_np_arrays</span>,</span><span class=\"param\">\t<span class=\"n\">non_zero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">c_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xc_family_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3", "modulename": "pyfock.Integrals.eval_xc_3", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_3.eval_xc_3", "modulename": "pyfock.Integrals.eval_xc_3", "qualname": "eval_xc_3", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.eval_xc_3_cupy", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "eval_xc_3_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">spin</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">blocksize</span><span class=\"o\">=</span><span class=\"mi\">10240</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">count_nonzero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">list_ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_libxc</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nstreams</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">ngpus</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">freemem</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">threads_per_block</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\ttype=&lt;class &#x27;numpy.float64&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">streams</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nb_streams</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_data_as_np_arrays</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.block_dens_func", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "block_dens_func", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">weights_block</span>,</span><span class=\"param\">\t<span class=\"n\">coords_block</span>,</span><span class=\"param\">\t<span class=\"n\">dmat</span>,</span><span class=\"param\">\t<span class=\"n\">funcid</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_data_as_np_arrays</span>,</span><span class=\"param\">\t<span class=\"n\">non_zero_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ao_grad_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">funcc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">c_family_code</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xc_family_dict</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">stream</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nb_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thread_x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thread_y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">threads_per_block</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_libxc</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.calc_F", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "calc_F", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weights_block</span>, </span><span class=\"param\"><span class=\"n\">v_rho_temp</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.calc_z", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "calc_z", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weights_block</span>, </span><span class=\"param\"><span class=\"n\">v_rho_temp</span>, </span><span class=\"param\"><span class=\"n\">ao_value_block</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.calc_sigma", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "calc_sigma", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho_grad_block_x</span>, </span><span class=\"param\"><span class=\"n\">rho_grad_block_y</span>, </span><span class=\"param\"><span class=\"n\">rho_grad_block_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.calc_z_gga", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "calc_z_gga", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">Fx</span>,</span><span class=\"param\">\t<span class=\"n\">Fy</span>,</span><span class=\"param\">\t<span class=\"n\">Fz</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_x</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_y</span>,</span><span class=\"param\">\t<span class=\"n\">ao_values_grad_block_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.elementwise_multiply", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "elementwise_multiply", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.eval_xc_3_cupy.fuse", "modulename": "pyfock.Integrals.eval_xc_3_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers", "modulename": "pyfock.Integrals.integral_helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.integral_helpers.fac", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "fac", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.fastFactorial_old", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "fastFactorial_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.LOOKUP_TABLE", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "LOOKUP_TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([                  1,                   1,                   2,\n                         6,                  24,                 120,\n                       720,                5040,               40320,\n                    362880,             3628800,            39916800,\n                 479001600,          6227020800,         87178291200,\n             1307674368000,      20922789888000,     355687428096000,\n          6402373705728000,  121645100408832000, 2432902008176640000])"}, {"fullname": "pyfock.Integrals.integral_helpers.fastFactorial", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "fastFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.comb", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "comb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.doublefactorial_old", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "doublefactorial_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.doublefactorial", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "doublefactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.c2k", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "c2k", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.calcS", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "calcS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">gamma</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.vlriPartial", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "vlriPartial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Ci</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">i</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.Fboys_old", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "Fboys_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.Fboys_jjgoings", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "Fboys_jjgoings", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.theta", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "theta", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span>, </span><span class=\"param\"><span class=\"n\">gamma_</span>, </span><span class=\"param\"><span class=\"n\">r</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.g", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "g", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lp</span>,</span><span class=\"param\">\t<span class=\"n\">lq</span>,</span><span class=\"param\">\t<span class=\"n\">rp</span>,</span><span class=\"param\">\t<span class=\"n\">rq</span>,</span><span class=\"param\">\t<span class=\"n\">i</span>,</span><span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">gammaP</span>,</span><span class=\"param\">\t<span class=\"n\">gammaQ</span>,</span><span class=\"param\">\t<span class=\"n\">PA</span>,</span><span class=\"param\">\t<span class=\"n\">PB</span>,</span><span class=\"param\">\t<span class=\"n\">QC</span>,</span><span class=\"param\">\t<span class=\"n\">QD</span>,</span><span class=\"param\">\t<span class=\"n\">PQ</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.innerLoop4c2e", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "innerLoop4c2e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">ma</span>,</span><span class=\"param\">\t<span class=\"n\">mb</span>,</span><span class=\"param\">\t<span class=\"n\">mc</span>,</span><span class=\"param\">\t<span class=\"n\">md</span>,</span><span class=\"param\">\t<span class=\"n\">na</span>,</span><span class=\"param\">\t<span class=\"n\">nb</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span>,</span><span class=\"param\">\t<span class=\"n\">nd</span>,</span><span class=\"param\">\t<span class=\"n\">gammaP</span>,</span><span class=\"param\">\t<span class=\"n\">gammaQ</span>,</span><span class=\"param\">\t<span class=\"n\">PI</span>,</span><span class=\"param\">\t<span class=\"n\">PJ</span>,</span><span class=\"param\">\t<span class=\"n\">QK</span>,</span><span class=\"param\">\t<span class=\"n\">QL</span>,</span><span class=\"param\">\t<span class=\"n\">PQ</span>,</span><span class=\"param\">\t<span class=\"n\">PQsqBy4delta</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.hermite_gauss_coeff", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "hermite_gauss_coeff", "kind": "function", "doc": "<p>Recursive definition of Hermite Gaussian coefficients.\nReturns a float.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>McMurchie-Davidson project:\n<a href=\"https://github.com/jjgoings/McMurchie-Davidson\">https://github.com/jjgoings/McMurchie-Davidson</a>\nLicensed under the BSD-3-Clause license\nSource: <a href=\"https://github.com/jjgoings/McMurchie-Davidson/blob/master/mmd/integrals/reference.py\">https://github.com/jjgoings/McMurchie-Davidson/blob/master/mmd/integrals/reference.py</a>\na: orbital exponent on Gaussian 'a' (e.g. alpha in the text)\nb: orbital exponent on Gaussian 'b' (e.g. beta in the text)\ni,j: orbital angular momentum number on Gaussian 'a' and 'b'\nt: number nodes in Hermite (depends on type of integral, \n   e.g. always zero for overlap integrals)\nQx: distance between origins of Gaussian 'a' and 'b'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">Qx</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">p</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.aux_hermite_int", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "aux_hermite_int", "kind": "function", "doc": "<p>Returns the Coulomb auxiliary Hermite integrals \nReturns a float.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>McMurchie-Davidson project:\n<a href=\"https://github.com/jjgoings/McMurchie-Davidson\">https://github.com/jjgoings/McMurchie-Davidson</a>\nLicensed under the BSD-3-Clause license\nSource: <a href=\"https://github.com/jjgoings/McMurchie-Davidson/blob/master/mmd/integrals/reference.py\">https://github.com/jjgoings/McMurchie-Davidson/blob/master/mmd/integrals/reference.py</a>\nArguments:\nt,u,v:   order of Coulomb Hermite derivative in x,y,z\n         (see defs in Helgaker and Taylor)\nn:       order of Boys function \nPCx,y,z: Cartesian vector distance between Gaussian \n         composite center P and nuclear center C\nRPC:     Distance between P and C</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">PCx</span>, </span><span class=\"param\"><span class=\"n\">PCy</span>, </span><span class=\"param\"><span class=\"n\">PCz</span>, </span><span class=\"param\"><span class=\"n\">RPC</span>, </span><span class=\"param\"><span class=\"n\">T</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">boys</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">n_min</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.TAYLOR_THRESHOLD", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "TAYLOR_THRESHOLD", "kind": "variable", "doc": "<p></p>\n", "default_value": "-25.0"}, {"fullname": "pyfock.Integrals.integral_helpers.hyp0minus", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "hyp0minus", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.hyp1f1_", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "hyp1f1_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.integral_helpers.Fboys", "modulename": "pyfock.Integrals.integral_helpers", "qualname": "Fboys", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">T</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_grad_symm", "modulename": "pyfock.Integrals.kin_mat_grad_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.kin_mat_grad_symm.kin_mat_grad_symm", "modulename": "pyfock.Integrals.kin_mat_grad_symm", "qualname": "kin_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_grad_symm.kin_mat_symm_grad_internal", "modulename": "pyfock.Integrals.kin_mat_grad_symm", "qualname": "kin_mat_symm_grad_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_atoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_grad_symm.kin_mat_symm_grad_internal_new", "modulename": "pyfock.Integrals.kin_mat_grad_symm", "qualname": "kin_mat_symm_grad_internal_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_atoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm", "modulename": "pyfock.Integrals.kin_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.kin_mat_symm.kin_mat_symm", "modulename": "pyfock.Integrals.kin_mat_symm", "qualname": "kin_mat_symm", "kind": "function", "doc": "<p>Compute the kinetic energy matrix for a given basis set.</p>\n\n<p>This function evaluates the one-electron kinetic energy integrals \n\u27e8\u03c7_i | -\u00bd\u2207\u00b2 | \u03c7_j\u27e9 for a set of contracted Gaussian basis functions defined in <code>basis</code>. \nIt uses an optimized backend with improved memory layout, early termination, \nand partial vectorization for enhanced performance.</p>\n\n<p>Block-wise computation is supported through the optional <code>slice</code> parameter.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object containing properties such as:\n    - bfs_coords: Cartesian coordinates of basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Normalization constants for primitives.\n    - bfs_contr_prim_norms: Normalization constants for contracted functions.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Number of atomic orbitals (contracted basis functions).</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> specifying the \n    matrix block to compute. Rows and columns refer to AOs. If <code>None</code> (default), \n    the entire kinetic energy matrix is calculated.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>T : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of kinetic energy integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Internally, this function:</p>\n\n<ul>\n<li>Pads coefficient/exponent arrays for uniform shape and Numba compatibility.</li>\n<li>Reduces redundant operations and loops.</li>\n<li>Utilizes an optimized <code>kin_mat_symm_internal_optimized</code> backend.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">kin_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T_block</span> <span class=\"o\">=</span> <span class=\"n\">kin_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm.kin_mat_symm_internal_optimized", "modulename": "pyfock.Integrals.kin_mat_symm", "qualname": "kin_mat_symm_internal_optimized", "kind": "function", "doc": "<p>Optimized internal function with several improvements:</p>\n\n<ol>\n<li>Pre-compute commonly used values</li>\n<li>Better loop structure</li>\n<li>Early termination conditions</li>\n<li>Reduced memory allocations</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm.kin_mat_symm_blocked", "modulename": "pyfock.Integrals.kin_mat_symm", "qualname": "kin_mat_symm_blocked", "kind": "function", "doc": "<p>Block-based computation for better cache locality with large matrices.\nThis can be particularly beneficial for very large basis sets.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">64</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.kin_mat_symm_cupy", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "kin_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.LOOKUP_TABLE", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "LOOKUP_TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([                  1,                   1,                   2,\n                         6,                  24,                 120,\n                       720,                5040,               40320,\n                    362880,             3628800,            39916800,\n                 479001600,          6227020800,         87178291200,\n             1307674368000,      20922789888000,     355687428096000,\n          6402373705728000,  121645100408832000, 2432902008176640000])"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.fastFactorial", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "fastFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.LOOKUP_TABLE_COMB", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "LOOKUP_TABLE_COMB", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 1,  0,  0,  0,  0,  0],\n       [ 1,  1,  0,  0,  0,  0],\n       [ 1,  2,  1,  0,  0,  0],\n       [ 1,  3,  3,  1,  0,  0],\n       [ 1,  4,  6,  4,  1,  0],\n       [ 1,  5, 10, 10,  5,  1]])"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.comb", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "comb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.doublefactorial", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "doublefactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.c2k", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "c2k", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.calcS", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "calcS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">gamma</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.kin_mat_symm_internal_cuda", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "kin_mat_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">lower_tri</span>,</span><span class=\"param\">\t<span class=\"n\">upper_tri</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_nonsymm</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_cupy.fuse", "modulename": "pyfock.Integrals.kin_mat_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.kin_mat_symm_shell_cupy", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "kin_mat_symm_shell_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.LOOKUP_TABLE", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "LOOKUP_TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([                  1,                   1,                   2,\n                         6,                  24,                 120,\n                       720,                5040,               40320,\n                    362880,             3628800,            39916800,\n                 479001600,          6227020800,         87178291200,\n             1307674368000,      20922789888000,     355687428096000,\n          6402373705728000,  121645100408832000, 2432902008176640000])"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.fastFactorial", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "fastFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.LOOKUP_TABLE_COMB", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "LOOKUP_TABLE_COMB", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 1,  0,  0,  0,  0,  0],\n       [ 1,  1,  0,  0,  0,  0],\n       [ 1,  2,  1,  0,  0,  0],\n       [ 1,  3,  3,  1,  0,  0],\n       [ 1,  4,  6,  4,  1,  0],\n       [ 1,  5, 10, 10,  5,  1]])"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.comb", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "comb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.doublefactorial", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "doublefactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.c2k", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "c2k", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.calcS", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "calcS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">fac1</span>, </span><span class=\"param\"><span class=\"n\">fac2</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.symmetrize", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.kin_mat_symm_shell_internal_cuda", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "kin_mat_symm_shell_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_offset</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nbfshell</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">nshells</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.kin_mat_symm_shell_cupy.fuse", "modulename": "pyfock.Integrals.kin_mat_symm_shell_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_4c2e_symm", "modulename": "pyfock.Integrals.mmd_4c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.mmd_4c2e_symm.mmd_4c2e_symm", "modulename": "pyfock.Integrals.mmd_4c2e_symm", "qualname": "mmd_4c2e_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_4c2e_symm.mmd_4c2e_symm_internal", "modulename": "pyfock.Integrals.mmd_4c2e_symm", "qualname": "mmd_4c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startD</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endD</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_4c2e_symm.mmd_4c2e_symm_internal2", "modulename": "pyfock.Integrals.mmd_4c2e_symm", "qualname": "mmd_4c2e_symm_internal2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startD</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endD</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_nuc_mat_symm", "modulename": "pyfock.Integrals.mmd_nuc_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.mmd_nuc_mat_symm.mmd_nuc_mat_symm", "modulename": "pyfock.Integrals.mmd_nuc_mat_symm", "qualname": "mmd_nuc_mat_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.mmd_nuc_mat_symm.mmd_nuc_mat_symm_internal", "modulename": "pyfock.Integrals.mmd_nuc_mat_symm", "qualname": "mmd_nuc_mat_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_grad_symm", "modulename": "pyfock.Integrals.nuc_mat_grad_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.nuc_mat_grad_symm.nuc_mat_grad_symm", "modulename": "pyfock.Integrals.nuc_mat_grad_symm", "qualname": "nuc_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_grad_symm.nuc_mat_grad_symm_internal", "modulename": "pyfock.Integrals.nuc_mat_grad_symm", "qualname": "nuc_mat_grad_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">isSchwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_grad_symm.nuc_mat_grad_symm_internal2", "modulename": "pyfock.Integrals.nuc_mat_grad_symm", "qualname": "nuc_mat_grad_symm_internal2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm", "modulename": "pyfock.Integrals.nuc_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.nuc_mat_symm.nuc_mat_symm", "modulename": "pyfock.Integrals.nuc_mat_symm", "qualname": "nuc_mat_symm", "kind": "function", "doc": "<p>Compute the nuclear attraction matrix for a given basis and molecular geometry.</p>\n\n<p>This function evaluates the one-electron nuclear attraction integrals \n\u27e8\u03c7_i | V_nuc | \u03c7_j\u27e9, where V_nuc is the Coulombic potential from the atomic nuclei.\nThe integrals are computed between all basis functions defined in <code>basis</code> and \nand the nuclei within the <code>mol</code> object.\nSo in principle, it can be used to compute the nuclear potential matrix due to the\nnuclei in one molecule, in the basis of another molecule.</p>\n\n<p>Efficient Numba-accelerated routines are used to improve performance. \nA partial block of the matrix can be computed by specifying a <code>slice</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Basis set object with fields including:\n    - bfs_coords: Cartesian coordinates of basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Normalization constants for primitives.\n    - bfs_contr_prim_norms: Normalization constants for contracted functions.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Number of atomic orbitals (contracted basis functions).</p>\n\n<p>mol : object\n    Molecule object containing:\n    - coordsBohrs: Cartesian coordinates of nuclei (in Bohr).\n    - Zcharges: Nuclear charges.\n    - natoms: Number of atoms.</p>\n\n<p>slice : list of int, optional\n    A 4-element list <code>[start_row, end_row, start_col, end_col]</code> defining \n    the sub-block of the matrix to compute. Rows and columns refer to AOs.\n    If <code>None</code> (default), the entire nuclear attraction matrix is computed.</p>\n\n<p>sqrt_ints4c2e_diag : ndarray, optional\n    Optional Schwarz screening preconditioner.\n    If provided, Schwarz screening is enabled to skip insignificant integrals.\n    If <code>None</code> (default), all integrals are computed without screening.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>V : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of nuclear attraction integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The integrals are evaluated using standard expressions over contracted Gaussians.\nIf Schwarz screening is used (<code>sqrt_ints4c2e_diag</code> is not None), a threshold-based \npruning is applied using precomputed upper bounds.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V_block</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">V_schwarz</span> <span class=\"o\">=</span> <span class=\"n\">nuc_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"n\">sqrt_diag</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm.nuc_mat_symm_internal", "modulename": "pyfock.Integrals.nuc_mat_symm", "qualname": "nuc_mat_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">isSchwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm.nuc_mat_symm_internal2", "modulename": "pyfock.Integrals.nuc_mat_symm", "qualname": "nuc_mat_symm_internal2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.nuc_mat_symm_cupy", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "nuc_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.LOOKUP_TABLE", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "LOOKUP_TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([                  1,                   1,                   2,\n                         6,                  24,                 120,\n                       720,                5040,               40320,\n                    362880,             3628800,            39916800,\n                 479001600,          6227020800,         87178291200,\n             1307674368000,      20922789888000,     355687428096000,\n          6402373705728000,  121645100408832000, 2432902008176640000])"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.fastFactorial", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "fastFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.LOOKUP_TABLE_COMB", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "LOOKUP_TABLE_COMB", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 1,  0,  0,  0,  0,  0],\n       [ 1,  1,  0,  0,  0,  0],\n       [ 1,  2,  1,  0,  0,  0],\n       [ 1,  3,  3,  1,  0,  0],\n       [ 1,  4,  6,  4,  1,  0],\n       [ 1,  5, 10, 10,  5,  1]])"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.comb", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "comb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.c2k", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "c2k", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.vlriPartial", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "vlriPartial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Ci</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">i</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.TABLE", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[1.25331414e-01, 1.26603846e-01, 1.27915838e-01, ...,\n        2.77627717e+18, 7.38774955e+18, 1.96677335e+19],\n       [3.75994241e-03, 3.87562795e-03, 3.99736995e-03, ...,\n        8.14962803e+18, 2.16964326e+19, 5.77860869e+19],\n       [1.87997121e-04, 1.97736120e-04, 2.08196352e-04, ...,\n        1.32968968e+19, 3.54154770e+19, 9.43653309e+19],\n       ...,\n       [1.49464652e-17, 2.40282538e-17, 3.90081178e-17, ...,\n        8.68691204e+19, 2.32816484e+20, 6.24089673e+20],\n       [7.32367344e-18, 1.20138648e-17, 1.99096660e-17, ...,\n        8.92749600e+19, 2.39312482e+20, 6.41628450e+20],\n       [3.73497509e-18, 6.25184045e-18, 1.05762530e-17, ...,\n        9.16135400e+19, 2.45629339e+20, 6.58690044e+20]])"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.taylor_cuda", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "taylor_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.hyp0minus", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "hyp0minus", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.hyp1f1_", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "hyp1f1_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.hyp1f1_new", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "hyp1f1_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">hyp0minus_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.Fboys", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "Fboys", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span>, </span><span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">hyp0minus_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.nuc_mat_symm_internal_cuda", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "nuc_mat_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsMol</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">lower_tri</span>,</span><span class=\"param\">\t<span class=\"n\">upper_tri</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_nonsymm</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">isSchwarz</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.nuc_mat_symm_cupy.fuse", "modulename": "pyfock.Integrals.nuc_mat_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_grad_symm", "modulename": "pyfock.Integrals.overlap_mat_grad_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.overlap_mat_grad_symm.overlap_mat_grad_symm", "modulename": "pyfock.Integrals.overlap_mat_grad_symm", "qualname": "overlap_mat_grad_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_grad_symm.overlap_mat_grad_symm_internal", "modulename": "pyfock.Integrals.overlap_mat_grad_symm", "qualname": "overlap_mat_grad_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_atoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_grad_symm.overlap_mat_grad_symm_internal_new", "modulename": "pyfock.Integrals.overlap_mat_grad_symm", "qualname": "overlap_mat_grad_symm_internal_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">natoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_atoms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm", "modulename": "pyfock.Integrals.overlap_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.overlap_mat_symm.overlap_mat_symm", "modulename": "pyfock.Integrals.overlap_mat_symm", "qualname": "overlap_mat_symm", "kind": "function", "doc": "<p>Compute the overlap matrix for a given basis set using symmetry-aware integrals.</p>\n\n<p>This function evaluates the overlap integrals \u27e8\u03c7_i | \u03c7_j\u27e9 between all pairs \nof basis functions defined in the <code>basis</code> object. It supports partial evaluation \nof the overlap matrix by specifying a slice.</p>\n\n<p>The integrals are computed using an efficient Numba-accelerated backend that \nbenefits from parallelization via <code>prange</code> and preprocessed NumPy arrays.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    A basis set object that contains information about basis functions, such as:\n    - bfs_coords: Cartesian coordinates of the basis function centers.\n    - bfs_coeffs: Contraction coefficients.\n    - bfs_expnts: Gaussian exponents.\n    - bfs_prim_norms: Primitive normalization constants.\n    - bfs_contr_prim_norms: Contraction normalization factors.\n    - bfs_lmn: Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim: Number of primitives per basis function.\n    - bfs_nao: Total number of atomic orbitals.</p>\n\n<p>slice : list of int, optional\n    A 4-element list specifying a sub-block of the matrix to compute:\n    [start_row, end_row, start_col, end_col].\n    If None (default), the full overlap matrix is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>S : ndarray of shape (end_row - start_row, end_col - start_col)\n    The computed (sub)matrix of overlap integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is optimized for performance using preallocated NumPy arrays\nand avoids nested Python lists which are not supported efficiently by Numba.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">S_block</span> <span class=\"o\">=</span> <span class=\"n\">overlap_mat_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm.overlap_mat_symm_internal", "modulename": "pyfock.Integrals.overlap_mat_symm", "qualname": "overlap_mat_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.overlap_mat_symm_cupy", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "overlap_mat_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.LOOKUP_TABLE", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "LOOKUP_TABLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([                  1,                   1,                   2,\n                         6,                  24,                 120,\n                       720,                5040,               40320,\n                    362880,             3628800,            39916800,\n                 479001600,          6227020800,         87178291200,\n             1307674368000,      20922789888000,     355687428096000,\n          6402373705728000,  121645100408832000, 2432902008176640000])"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.fastFactorial", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "fastFactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.comb", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "comb", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.doublefactorial", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "doublefactorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.c2k", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "c2k", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.calcS", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "calcS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">la</span>, </span><span class=\"param\"><span class=\"n\">lb</span>, </span><span class=\"param\"><span class=\"n\">gamma</span>, </span><span class=\"param\"><span class=\"n\">PA</span>, </span><span class=\"param\"><span class=\"n\">PB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.overlap_mat_symm_internal_cuda", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "overlap_mat_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">lower_tri</span>,</span><span class=\"param\">\t<span class=\"n\">upper_tri</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">both_tri_nonsymm</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.overlap_mat_symm_cupy.fuse", "modulename": "pyfock.Integrals.overlap_mat_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm", "modulename": "pyfock.Integrals.rys_2c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm.rys_2c2e_symm", "modulename": "pyfock.Integrals.rys_2c2e_symm", "qualname": "rys_2c2e_symm", "kind": "function", "doc": "<p>Compute symmetric two-center two-electron integrals using Rys quadrature.</p>\n\n<p>This function evaluates the electron repulsion integrals (ERIs)\ninvolving only two centers (2c2e), using the Rys quadrature method. \nThe integrals are computed efficiently using Numba, and the data is prepared \naccordingly for compatibility with JIT compilation. It assumes symmetry, \nand computes only a specified block if requested.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    A basis set object containing the basis function data. It must have attributes:\n    - bfs_coords : list of (x, y, z) coordinates of basis function centers\n    - bfs_contr_prim_norms : contraction-normalization factors\n    - bfs_lmn : angular momentum tuples (l, m, n)\n    - bfs_nprim : number of primitives for each basis function\n    - bfs_coeffs : contraction coefficients\n    - bfs_expnts : primitive exponents\n    - bfs_prim_norms : primitive normalization constants\n    - bfs_nao : total number of atomic orbitals (basis functions)</p>\n\n<p>slice : list of int, optional\n    A four-element list <code>[start_row, end_row, start_col, end_col]</code> specifying the \n    row and column ranges of the matrix to be computed. If None, the full matrix \n    is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints2c2e : ndarray\n    A 2D numpy array of shape <code>(end_row - start_row, end_col - start_col)</code> \n    containing the computed symmetric two-center two-electron integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function prepares the basis set data in a Numba-friendly format by \nconverting ragged lists into padded 2D arrays, where the second dimension \ncorresponds to the maximum number of primitives. The core integral computation \nis offloaded to a Numba-accelerated function <code>rys_2c2e_symm_internal</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm.rys_2c2e_symm_internal", "modulename": "pyfock.Integrals.rys_2c2e_symm", "qualname": "rys_2c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy", "modulename": "pyfock.Integrals.rys_2c2e_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy.rys_2c2e_symm_cupy", "modulename": "pyfock.Integrals.rys_2c2e_symm_cupy", "qualname": "rys_2c2e_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy.rys_2c2e_symm_internal_cuda", "modulename": "pyfock.Integrals.rys_2c2e_symm_cupy", "qualname": "rys_2c2e_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">start_row</span>,</span><span class=\"param\">\t<span class=\"n\">end_row</span>,</span><span class=\"param\">\t<span class=\"n\">start_col</span>,</span><span class=\"param\">\t<span class=\"n\">end_col</span>,</span><span class=\"param\">\t<span class=\"n\">tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">no_symm</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.rys_2c2e_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_row</span>, </span><span class=\"param\"><span class=\"n\">end_row</span>, </span><span class=\"param\"><span class=\"n\">start_col</span>, </span><span class=\"param\"><span class=\"n\">end_col</span>, </span><span class=\"param\"><span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_2c2e_symm_cupy.fuse", "modulename": "pyfock.Integrals.rys_2c2e_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm", "modulename": "pyfock.Integrals.rys_3c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm.rys_3c2e_symm", "modulename": "pyfock.Integrals.rys_3c2e_symm", "qualname": "rys_3c2e_symm", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals using\nthe Rys quadrature method with symmetry considerations.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where A and B are\nbasis functions from a primary basis set and C is from an auxiliary basis set.\nSymmetry in the first two indices is exploited ((A B | C) = (B A | C)),\nso only the upper-triangular part of the (A,B) block is computed and the (B A | C)\nintegrals are formed by symmetry.\nThe implementation uses Numba-accelerated backends with symmetry-aware\noptimizations and optional Schwarz screening to skip negligible contributions.\nSymmetry is utilized to only compute N_{bf}*(N_{bf}+1)/2*N_{auxbf}</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing information about atomic orbitals, such as:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>, \n    but typically used for resolution-of-the-identity (RI) expansions.</p>\n\n<p>slice : list of int, optional\n    A 6-element list specifying a subset of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C]\n    If None (default), computes all N_{bf}*N_{bf}*N_{auxbf} integrals.</p>\n\n<p>schwarz : bool, optional\n    If True, applies Schwarz screening to skip calculations where the \n    product of integral bounds is below <code>schwarz_threshold</code>.</p>\n\n<p>schwarz_threshold : float, optional\n    The threshold for Schwarz screening (default is 1e-9).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray of shape \n    (Nbf, Nbf, Nauxbf) or \n    (end_A - start_A, end_B - start_B, end_C - start_C) \n    if slice is given.\n    The computed 3-center 2-electron integrals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Uses preallocated NumPy arrays to store primitive data for efficient Numba processing.</li>\n<li>Handles irregular contraction patterns by padding primitive arrays to the \nsize of the largest contraction.</li>\n<li>If Schwarz screening is enabled, precomputes diagonal two-electron integrals \nand uses their square roots for screening.</li>\n<li>Symmetry relations are exploited to avoid redundant calculations.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_block</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_screened</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">,</span> <span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm.rys_3c2e_symm_internal", "modulename": "pyfock.Integrals.rys_3c2e_symm", "qualname": "rys_3c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy.rys_3c2e_symm_cupy", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "qualname": "rys_3c2e_symm_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy.rys_3c2e_symm_internal_cuda", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "qualname": "rys_3c2e_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">no_symm</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy.rys_3c2e_symm_internal_cuda_new", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "qualname": "rys_3c2e_symm_internal_cuda_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">no_symm</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy.symmetrize", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy.fuse", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32.rys_3c2e_symm_cupy_fp32", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "qualname": "rys_3c2e_symm_cupy_fp32", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32.rys_3c2e_symm_internal_cuda", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "qualname": "rys_3c2e_symm_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">tri_symm</span>,</span><span class=\"param\">\t<span class=\"n\">no_symm</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32.symmetrize", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "qualname": "symmetrize", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32.fuse", "modulename": "pyfock.Integrals.rys_3c2e_symm_cupy_fp32", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_tri", "modulename": "pyfock.Integrals.rys_3c2e_tri", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_3c2e_tri.rys_3c2e_tri", "modulename": "pyfock.Integrals.rys_3c2e_tri", "qualname": "rys_3c2e_tri", "kind": "function", "doc": "<p>Compute three-center two-electron (3c2e) electron repulsion integrals using\nthe Rys quadrature method with symmetry considerations, stored in packed\ntriangular form for memory efficiency.</p>\n\n<p>This function evaluates integrals of the form (A B | C), where A and B are\nbasis functions from a primary basis set and C is from an auxiliary basis set.\nSymmetry in the first two indices is exploited ((A B | C) = (B A | C)),\nso only the upper-triangular part of the (A,B) block is computed and stored.\nThe resulting array has shape (N_{bf}*(N_{bf}+1)/2, N_{auxbf}), where the first\nindex corresponds to a flattened 1D triangular index over basis function pairs.</p>\n\n<p>Unlike <code>rys_3c2e_symm</code>, this routine does not support computing arbitrary slices\n\u2014 the full triangular set is always evaluated.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing information about atomic orbitals, such as:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>auxbasis : object\n    Auxiliary basis set object with the same attributes as <code>basis</code>,\n    typically used for resolution-of-the-identity (RI) expansions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints3c2e : ndarray of shape (Nbf*(Nbf+1)//2, Nauxbf)\n    The computed 3-center 2-electron integrals in packed triangular form.\n    The mapping from a pair (i, j) with i \u2264 j to the first dimension index\n    follows standard upper-triangular packing order.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This is a memory-efficient variant of <code>rys_3c2e_symm</code> that avoids storing\nthe full (Nbf, Nbf, Nauxbf) array.</li>\n<li>Uses preallocated NumPy arrays for primitive data to ensure efficient Numba processing.</li>\n<li>Handles irregular contraction patterns by padding primitive arrays to the size\nof the largest contraction in the set.</li>\n<li>No Schwarz screening or partial computation is available in this function.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ints_tri</span> <span class=\"o\">=</span> <span class=\"n\">rys_3c2e_tri</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"n\">auxbasis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Retrieve value for pair (i, j) and auxiliary k:</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">packed_index</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">Nbf</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">j</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">i</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"n\">Nbf</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">ints_tri</span><span class=\"p\">[</span><span class=\"n\">packed_index</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">basis</span><span class=\"o\">.</span><span class=\"n\">bfs_nao</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_3c2e_tri.rys_3c2e_tri_internal", "modulename": "pyfock.Integrals.rys_3c2e_tri", "qualname": "rys_3c2e_tri_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">nbf</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm", "modulename": "pyfock.Integrals.rys_4c2e_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm.rys_4c2e_symm", "modulename": "pyfock.Integrals.rys_4c2e_symm", "qualname": "rys_4c2e_symm", "kind": "function", "doc": "<p>Compute four-center two-electron (4c2e) electron repulsion integrals (ERIs) \nusing the Rys quadrature method with exploitation of 8-fold permutational \nsymmetry.</p>\n\n<p>This function evaluates integrals of the form (A B | C D), where A, B, C, D \nare basis functions from the same primary basis set. It uses Numba-accelerated \nbackends and symmetry-aware optimizations to reduce computational cost.</p>\n\n<h2 id=\"symmetries-exploited\">Symmetries exploited</h2>\n\n<p>The 4c2e integrals obey the following permutational symmetry relations:</p>\n\n<pre><code>(A B | C D) = (B A | C D)   # exchange within bra\n            = (A B | D C)  # exchange within ket\n            = (B A | D C)  \n            = (C D | A B)  # bra \u2194 ket exchange\n            = (D C | A B)\n            = (C D | B A)\n            = (D C | B A)\n</code></pre>\n\n<p>These 8 equivalent permutations mean that only a subset of integrals \nneeds to be explicitly computed; the rest can be obtained by symmetry.</p>\n\n<p>This reduces the number of independent integrals from:\n    N_bf^4   \u2192   N_bf<em>(N_bf+1)/2 * N_bf</em>(N_bf+1)/2\nwhen computing the full tensor.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>basis : object\n    Primary basis set object containing:\n    - bfs_coords : Cartesian coordinates of basis function centers.\n    - bfs_coeffs : Contraction coefficients.\n    - bfs_expnts : Gaussian exponents.\n    - bfs_prim_norms : Primitive normalization constants.\n    - bfs_contr_prim_norms : Contraction normalization factors.\n    - bfs_lmn : Angular momentum quantum numbers (\u2113, m, n).\n    - bfs_nprim : Number of primitives per basis function.\n    - bfs_shell_index : Index of the shell each basis function belongs to.\n    - bfs_nao : Total number of atomic orbitals.</p>\n\n<p>slice : list of int, optional\n    An 8-element list specifying a sub-block of integrals to compute:\n    [start_A, end_A, start_B, end_B, start_C, end_C, start_D, end_D]\n    If None (default), computes the full (Nbf, Nbf, Nbf, Nbf) block.</p>\n\n<pre><code>**Note:** When slices are used, not all 8-fold symmetries may be \navailable because the requested block may not contain all \nsymmetric permutations. In such cases, only the applicable \nsymmetries are used.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ints4c2e : ndarray\n    The computed 4-center 2-electron integrals for the requested range.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Precomputes and stores basis set data in NumPy arrays for Numba efficiency.</li>\n<li>Exploits all possible symmetry permutations when the full tensor is \ncomputed (no slice) to reduce redundant work.</li>\n<li>If a slice is specified, symmetry exploitation is limited to the \npermutations that fall within the slice's index ranges.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_full</span> <span class=\"o\">=</span> <span class=\"n\">rys_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eri_block</span> <span class=\"o\">=</span> <span class=\"n\">rys_4c2e_symm</span><span class=\"p\">(</span><span class=\"n\">basis</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm.rys_4c2e_symm_internal", "modulename": "pyfock.Integrals.rys_4c2e_symm", "qualname": "rys_4c2e_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startD</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endD</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm.rys_4c2e_symm_old", "modulename": "pyfock.Integrals.rys_4c2e_symm", "qualname": "rys_4c2e_symm_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_4c2e_symm.rys_4c2e_symm_internal_old", "modulename": "pyfock.Integrals.rys_4c2e_symm", "qualname": "rys_4c2e_symm_internal_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startD</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endD</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers", "modulename": "pyfock.Integrals.rys_helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_helpers.coulomb_rys", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "coulomb_rys", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">roots</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">rpq2</span>,</span><span class=\"param\">\t<span class=\"n\">rho</span>,</span><span class=\"param\">\t<span class=\"n\">norder</span>,</span><span class=\"param\">\t<span class=\"n\">n</span>,</span><span class=\"param\">\t<span class=\"n\">m</span>,</span><span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">ma</span>,</span><span class=\"param\">\t<span class=\"n\">mb</span>,</span><span class=\"param\">\t<span class=\"n\">mc</span>,</span><span class=\"param\">\t<span class=\"n\">md</span>,</span><span class=\"param\">\t<span class=\"n\">na</span>,</span><span class=\"param\">\t<span class=\"n\">nb</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span>,</span><span class=\"param\">\t<span class=\"n\">nd</span>,</span><span class=\"param\">\t<span class=\"n\">alphaik</span>,</span><span class=\"param\">\t<span class=\"n\">alphajk</span>,</span><span class=\"param\">\t<span class=\"n\">alphakk</span>,</span><span class=\"param\">\t<span class=\"n\">alphalk</span>,</span><span class=\"param\">\t<span class=\"n\">I</span>,</span><span class=\"param\">\t<span class=\"n\">J</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">L</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.coulomb_rys_3c2e", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "coulomb_rys_3c2e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">roots</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">rpq2</span>,</span><span class=\"param\">\t<span class=\"n\">rho</span>,</span><span class=\"param\">\t<span class=\"n\">norder</span>,</span><span class=\"param\">\t<span class=\"n\">n</span>,</span><span class=\"param\">\t<span class=\"n\">m</span>,</span><span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">ma</span>,</span><span class=\"param\">\t<span class=\"n\">mb</span>,</span><span class=\"param\">\t<span class=\"n\">mc</span>,</span><span class=\"param\">\t<span class=\"n\">md</span>,</span><span class=\"param\">\t<span class=\"n\">na</span>,</span><span class=\"param\">\t<span class=\"n\">nb</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span>,</span><span class=\"param\">\t<span class=\"n\">nd</span>,</span><span class=\"param\">\t<span class=\"n\">alphaik</span>,</span><span class=\"param\">\t<span class=\"n\">alphajk</span>,</span><span class=\"param\">\t<span class=\"n\">alphakk</span>,</span><span class=\"param\">\t<span class=\"n\">alphalk</span>,</span><span class=\"param\">\t<span class=\"n\">I</span>,</span><span class=\"param\">\t<span class=\"n\">J</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">L</span>,</span><span class=\"param\">\t<span class=\"n\">P</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.coulomb_rys_new", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "coulomb_rys_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">roots</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">rpq2</span>,</span><span class=\"param\">\t<span class=\"n\">rho</span>,</span><span class=\"param\">\t<span class=\"n\">norder</span>,</span><span class=\"param\">\t<span class=\"n\">n</span>,</span><span class=\"param\">\t<span class=\"n\">m</span>,</span><span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">ma</span>,</span><span class=\"param\">\t<span class=\"n\">mb</span>,</span><span class=\"param\">\t<span class=\"n\">mc</span>,</span><span class=\"param\">\t<span class=\"n\">md</span>,</span><span class=\"param\">\t<span class=\"n\">na</span>,</span><span class=\"param\">\t<span class=\"n\">nb</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span>,</span><span class=\"param\">\t<span class=\"n\">nd</span>,</span><span class=\"param\">\t<span class=\"n\">alphaik</span>,</span><span class=\"param\">\t<span class=\"n\">alphajk</span>,</span><span class=\"param\">\t<span class=\"n\">alphakk</span>,</span><span class=\"param\">\t<span class=\"n\">alphalk</span>,</span><span class=\"param\">\t<span class=\"n\">I</span>,</span><span class=\"param\">\t<span class=\"n\">J</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">L</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.coulomb_rys_fast", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "coulomb_rys_fast", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">roots</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">norder</span>,</span><span class=\"param\">\t<span class=\"n\">la</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span>,</span><span class=\"param\">\t<span class=\"n\">lc</span>,</span><span class=\"param\">\t<span class=\"n\">ld</span>,</span><span class=\"param\">\t<span class=\"n\">ma</span>,</span><span class=\"param\">\t<span class=\"n\">mb</span>,</span><span class=\"param\">\t<span class=\"n\">mc</span>,</span><span class=\"param\">\t<span class=\"n\">md</span>,</span><span class=\"param\">\t<span class=\"n\">na</span>,</span><span class=\"param\">\t<span class=\"n\">nb</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span>,</span><span class=\"param\">\t<span class=\"n\">nd</span>,</span><span class=\"param\">\t<span class=\"n\">alphaik</span>,</span><span class=\"param\">\t<span class=\"n\">alphajk</span>,</span><span class=\"param\">\t<span class=\"n\">alphakk</span>,</span><span class=\"param\">\t<span class=\"n\">alphalk</span>,</span><span class=\"param\">\t<span class=\"n\">I</span>,</span><span class=\"param\">\t<span class=\"n\">J</span>,</span><span class=\"param\">\t<span class=\"n\">K</span>,</span><span class=\"param\">\t<span class=\"n\">L</span>,</span><span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">A</span>,</span><span class=\"param\">\t<span class=\"n\">B</span>,</span><span class=\"param\">\t<span class=\"n\">Ap</span>,</span><span class=\"param\">\t<span class=\"n\">Bp</span>,</span><span class=\"param\">\t<span class=\"n\">ABsrt</span>,</span><span class=\"param\">\t<span class=\"n\">factor</span>,</span><span class=\"param\">\t<span class=\"n\">P</span>,</span><span class=\"param\">\t<span class=\"n\">Q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Int1d", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Int1d", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">ix</span>, </span><span class=\"param\"><span class=\"n\">jx</span>, </span><span class=\"param\"><span class=\"n\">kx</span>, </span><span class=\"param\"><span class=\"n\">lx</span>, </span><span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">xj</span>, </span><span class=\"param\"><span class=\"n\">xk</span>, </span><span class=\"param\"><span class=\"n\">xl</span>, </span><span class=\"param\"><span class=\"n\">alphai</span>, </span><span class=\"param\"><span class=\"n\">alphaj</span>, </span><span class=\"param\"><span class=\"n\">alphak</span>, </span><span class=\"param\"><span class=\"n\">alphal</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Recur", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Recur", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">t</span>,</span><span class=\"param\">\t<span class=\"n\">i</span>,</span><span class=\"param\">\t<span class=\"n\">j</span>,</span><span class=\"param\">\t<span class=\"n\">k</span>,</span><span class=\"param\">\t<span class=\"n\">l</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span>,</span><span class=\"param\">\t<span class=\"n\">xj</span>,</span><span class=\"param\">\t<span class=\"n\">xk</span>,</span><span class=\"param\">\t<span class=\"n\">xl</span>,</span><span class=\"param\">\t<span class=\"n\">alphai</span>,</span><span class=\"param\">\t<span class=\"n\">alphaj</span>,</span><span class=\"param\">\t<span class=\"n\">alphak</span>,</span><span class=\"param\">\t<span class=\"n\">alphal</span>,</span><span class=\"param\">\t<span class=\"n\">A</span>,</span><span class=\"param\">\t<span class=\"n\">B</span>,</span><span class=\"param\">\t<span class=\"n\">Ap</span>,</span><span class=\"param\">\t<span class=\"n\">Bp</span>,</span><span class=\"param\">\t<span class=\"n\">ABsrt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Recur_3c2e", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Recur_3c2e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">t</span>,</span><span class=\"param\">\t<span class=\"n\">i</span>,</span><span class=\"param\">\t<span class=\"n\">j</span>,</span><span class=\"param\">\t<span class=\"n\">k</span>,</span><span class=\"param\">\t<span class=\"n\">l</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span>,</span><span class=\"param\">\t<span class=\"n\">xj</span>,</span><span class=\"param\">\t<span class=\"n\">xk</span>,</span><span class=\"param\">\t<span class=\"n\">xl</span>,</span><span class=\"param\">\t<span class=\"n\">alphai</span>,</span><span class=\"param\">\t<span class=\"n\">alphaj</span>,</span><span class=\"param\">\t<span class=\"n\">alphak</span>,</span><span class=\"param\">\t<span class=\"n\">alphal</span>,</span><span class=\"param\">\t<span class=\"n\">A</span>,</span><span class=\"param\">\t<span class=\"n\">B</span>,</span><span class=\"param\">\t<span class=\"n\">Ap</span>,</span><span class=\"param\">\t<span class=\"n\">ABsrt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Recur_fast", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Recur_fast", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">G</span>,</span><span class=\"param\">\t<span class=\"n\">t</span>,</span><span class=\"param\">\t<span class=\"n\">i</span>,</span><span class=\"param\">\t<span class=\"n\">j</span>,</span><span class=\"param\">\t<span class=\"n\">k</span>,</span><span class=\"param\">\t<span class=\"n\">l</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span>,</span><span class=\"param\">\t<span class=\"n\">xj</span>,</span><span class=\"param\">\t<span class=\"n\">xk</span>,</span><span class=\"param\">\t<span class=\"n\">xl</span>,</span><span class=\"param\">\t<span class=\"n\">alphai</span>,</span><span class=\"param\">\t<span class=\"n\">alphaj</span>,</span><span class=\"param\">\t<span class=\"n\">alphak</span>,</span><span class=\"param\">\t<span class=\"n\">alphal</span>,</span><span class=\"param\">\t<span class=\"n\">A</span>,</span><span class=\"param\">\t<span class=\"n\">B</span>,</span><span class=\"param\">\t<span class=\"n\">Ap</span>,</span><span class=\"param\">\t<span class=\"n\">Bp</span>,</span><span class=\"param\">\t<span class=\"n\">ABsrt</span>,</span><span class=\"param\">\t<span class=\"n\">Px</span>,</span><span class=\"param\">\t<span class=\"n\">Qx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Recur_new", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Recur_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">xj</span>, </span><span class=\"param\"><span class=\"n\">xk</span>, </span><span class=\"param\"><span class=\"n\">xl</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">Px</span>, </span><span class=\"param\"><span class=\"n\">Qx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.LOOKUP_TABLE_COMB", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "LOOKUP_TABLE_COMB", "kind": "variable", "doc": "<p>Compute and  output I(i,j,k,l) from I(i+j,0,k+l,0) (G)</p>\n", "default_value": "array([[ 1,  0,  0,  0,  0,  0],\n       [ 1,  1,  0,  0,  0,  0],\n       [ 1,  2,  1,  0,  0,  0],\n       [ 1,  3,  3,  1,  0,  0],\n       [ 1,  4,  6,  4,  1,  0],\n       [ 1,  5, 10, 10,  5,  1]])"}, {"fullname": "pyfock.Integrals.rys_helpers.Shift", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Shift", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">xij</span>, </span><span class=\"param\"><span class=\"n\">xkl</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Shift_3c2e", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Shift_3c2e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">xij</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.RecurFactors", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "RecurFactors", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">Px</span>, </span><span class=\"param\"><span class=\"n\">Qx</span>, </span><span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">xk</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Roots", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Roots", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.nERIRys", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "nERIRys", "kind": "function", "doc": "<p>Calculate Rys polynomials for two-electron integrals</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">q1</span>, </span><span class=\"param\"><span class=\"n\">q2</span>, </span><span class=\"param\"><span class=\"n\">q3</span>, </span><span class=\"param\"><span class=\"n\">q4</span>, </span><span class=\"param\"><span class=\"n\">a12</span>, </span><span class=\"param\"><span class=\"n\">a34</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">C</span>, </span><span class=\"param\"><span class=\"n\">D</span>, </span><span class=\"param\"><span class=\"n\">P</span>, </span><span class=\"param\"><span class=\"n\">Q</span>, </span><span class=\"param\"><span class=\"n\">sRys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.ChebGausInt", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "ChebGausInt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eps</span>,</span><span class=\"param\">\t<span class=\"n\">M</span>,</span><span class=\"param\">\t<span class=\"n\">a12</span>,</span><span class=\"param\">\t<span class=\"n\">a34</span>,</span><span class=\"param\">\t<span class=\"n\">qx1</span>,</span><span class=\"param\">\t<span class=\"n\">qx2</span>,</span><span class=\"param\">\t<span class=\"n\">qx3</span>,</span><span class=\"param\">\t<span class=\"n\">qx4</span>,</span><span class=\"param\">\t<span class=\"n\">qy1</span>,</span><span class=\"param\">\t<span class=\"n\">qy2</span>,</span><span class=\"param\">\t<span class=\"n\">qy3</span>,</span><span class=\"param\">\t<span class=\"n\">qy4</span>,</span><span class=\"param\">\t<span class=\"n\">qz1</span>,</span><span class=\"param\">\t<span class=\"n\">qz2</span>,</span><span class=\"param\">\t<span class=\"n\">qz3</span>,</span><span class=\"param\">\t<span class=\"n\">qz4</span>,</span><span class=\"param\">\t<span class=\"n\">x1</span>,</span><span class=\"param\">\t<span class=\"n\">x2</span>,</span><span class=\"param\">\t<span class=\"n\">x3</span>,</span><span class=\"param\">\t<span class=\"n\">x4</span>,</span><span class=\"param\">\t<span class=\"n\">y1</span>,</span><span class=\"param\">\t<span class=\"n\">y2</span>,</span><span class=\"param\">\t<span class=\"n\">y3</span>,</span><span class=\"param\">\t<span class=\"n\">y4</span>,</span><span class=\"param\">\t<span class=\"n\">z1</span>,</span><span class=\"param\">\t<span class=\"n\">z2</span>,</span><span class=\"param\">\t<span class=\"n\">z3</span>,</span><span class=\"param\">\t<span class=\"n\">z4</span>,</span><span class=\"param\">\t<span class=\"n\">Px</span>,</span><span class=\"param\">\t<span class=\"n\">Py</span>,</span><span class=\"param\">\t<span class=\"n\">Pz</span>,</span><span class=\"param\">\t<span class=\"n\">Qx</span>,</span><span class=\"param\">\t<span class=\"n\">Qy</span>,</span><span class=\"param\">\t<span class=\"n\">Qz</span>,</span><span class=\"param\">\t<span class=\"n\">T</span>,</span><span class=\"param\">\t<span class=\"n\">sRys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.clenshaw_d1", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "clenshaw_d1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">roots_or_weights</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Rootn", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Rootn", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Root1", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Root1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Root2", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Root2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.R13", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "R13", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.190163509193487"}, {"fullname": "pyfock.Integrals.rys_helpers.Root3", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Root3", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Root4", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Root4", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.Root5", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "Root5", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">roots</span>, </span><span class=\"param\"><span class=\"n\">weights</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_SMALLX_R0", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_SMALLX_R0", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([5.00000000e-01, 1.30693606e-01, 2.86930639e+00, 6.03769247e-02,\n       7.76823356e-01, 6.66279972e+00, 3.48198973e-02, 3.81567185e-01,\n       1.73730727e+00, 1.18463056e+01, 2.26659266e-02, 2.31271692e-01,\n       8.57346024e-01, 2.97353038e+00, 1.84151860e+01, 1.59332950e-02,\n       1.56470468e-01, 5.26583263e-01, 1.45549494e+00, 4.47729155e+00,\n       2.63682265e+01, 1.18138085e-02, 1.13378325e-01, 3.61435462e-01,\n       8.95273038e-01, 2.16718307e+00, 6.24592175e+00, 3.57049945e+01,\n       9.10961294e-03, 8.61307788e-02, 2.65469364e-01, 6.17523743e-01,\n       1.32902521e+00, 2.98910780e+00, 8.27832917e+00, 4.64253043e+01,\n       7.23882686e-03, 6.77448563e-02, 2.04150493e-01, 4.56331994e-01,\n       9.17291737e-01, 1.82439330e+00, 3.91978689e+00, 1.05739967e+01,\n       5.85290652e+01, 5.89080682e-03, 5.47259249e-02, 1.62326093e-01,\n       3.53152679e-01, 6.79442422e-01, 1.25739400e+00, 2.37971762e+00,\n       4.95846895e+00, 1.31326529e+01, 7.20162286e+01, 4.88733613e-03,\n       4.51570088e-02, 1.32400371e-01, 2.82536184e-01, 5.27466701e-01,\n       9.31667489e-01, 1.63612501e+00, 2.99411140e+00, 6.10473807e+00,\n       1.59541438e+01, 8.68867666e+01, 4.12019185e-03, 3.79111813e-02,\n       1.10188286e-01, 2.31795308e-01, 4.23456302e-01, 7.24213385e-01,\n       1.21133175e+00, 2.05253340e+00, 3.66706307e+00, 7.35834812e+00,\n       1.90383766e+01, 1.03140662e+02])"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_SMALLX_R1", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_SMALLX_R1", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([-2.00000000e-01, -2.90430236e-02, -6.37623643e-01, -9.28875764e-03,\n       -1.19511286e-01, -1.02504611e+00, -4.09645851e-03, -4.48902571e-02,\n       -2.04389091e-01, -1.39368302e+00, -2.15865968e-03, -2.20258754e-02,\n       -8.16520023e-02, -2.83193370e-01, -1.75382724e+00, -1.27466360e-03,\n       -1.25176374e-02, -4.21266611e-02, -1.16439595e-01, -3.58183324e-01,\n       -2.10945812e+00, -8.14745411e-04, -7.81919486e-03, -2.49265836e-02,\n       -6.17429681e-02, -1.49460902e-01, -4.30753224e-01, -2.46241342e+00,\n       -5.52097754e-04, -5.22004720e-03, -1.60890524e-02, -3.74256814e-02,\n       -8.05469825e-02, -1.81158048e-01, -5.01716919e-01, -2.81365481e+00,\n       -3.91287938e-04, -3.66188412e-03, -1.10351618e-02, -2.46665943e-02,\n       -4.95833371e-02, -9.86158540e-02, -2.11880372e-01, -5.71567390e-01,\n       -3.16373325e+00, -2.87356430e-04, -2.66955731e-03, -7.91834598e-03,\n       -1.72269599e-02, -3.31435328e-02, -6.13362926e-02, -1.16083786e-01,\n       -2.41876534e-01, -6.40617216e-01, -3.51298676e+00, -2.17214939e-04,\n       -2.00697817e-03, -5.88446093e-03, -1.25571637e-02, -2.34429645e-02,\n       -4.14074440e-02, -7.27166672e-02, -1.33071618e-01, -2.71321692e-01,\n       -7.09073058e-01, -3.86163407e+00, -1.68171096e-04, -1.54739515e-03,\n       -4.49748105e-03, -9.46103299e-03, -1.72839307e-02, -2.95597300e-02,\n       -4.94421123e-02, -8.37768735e-02, -1.49676044e-01, -3.00340740e-01,\n       -7.77076597e-01, -4.20982295e+00])"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_SMALLX_W0", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_SMALLX_W0", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([1.        , 0.65214515, 0.34785485, 0.46791393, 0.36076157,\n       0.17132449, 0.36268378, 0.31370665, 0.22238103, 0.10122854,\n       0.29552422, 0.26926672, 0.21908636, 0.14945135, 0.06667134,\n       0.24914705, 0.23349254, 0.20316743, 0.16007833, 0.10693933,\n       0.04717534, 0.21526385, 0.20519846, 0.1855384 , 0.15720317,\n       0.12151857, 0.08015809, 0.03511946, 0.18945061, 0.18260342,\n       0.16915652, 0.14959599, 0.12462897, 0.09515851, 0.06225352,\n       0.02715246, 0.16914238, 0.16427648, 0.15468468, 0.14064291,\n       0.12255521, 0.10094204, 0.07642573, 0.04971455, 0.02161601,\n       0.15275339, 0.14917299, 0.14209611, 0.13168864, 0.11819453,\n       0.10193012, 0.08327674, 0.06267205, 0.04060143, 0.01761401,\n       0.13925187, 0.1365415 , 0.1311735 , 0.12325238, 0.1129323 ,\n       0.10041414, 0.08594161, 0.06979647, 0.05229334, 0.0337749 ,\n       0.014628  , 0.1279382 , 0.12583746, 0.12167047, 0.11550567,\n       0.10744427, 0.09761865, 0.08619016, 0.07334648, 0.05929858,\n       0.04427744, 0.02853139, 0.01234123])"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_SMALLX_W1", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_SMALLX_W1", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([-0.33333333, -0.12271362, -0.21061971, -0.05648769, -0.14907719,\n       -0.12776846, -0.03138443, -0.08980462, -0.12931437, -0.08282991,\n       -0.01968676, -0.05617376, -0.09711527, -0.10297926, -0.05737828,\n       -0.01340446, -0.03714026, -0.06979803, -0.08990321, -0.08120295,\n       -0.04188443, -0.00967628, -0.02581008, -0.05055928, -0.07199721,\n       -0.07873906, -0.06471183, -0.0318396 , -0.00729569, -0.01869758,\n       -0.03738554, -0.05645268, -0.06842914, -0.06770534, -0.05238098,\n       -0.02498637, -0.00568845, -0.01401761, -0.0282794 , -0.04429748,\n       -0.05719238, -0.06264413, -0.05801979, -0.04308018, -0.02011391,\n       -0.00455481, -0.01081207, -0.02185832, -0.0350659 , -0.04720125,\n       -0.05510797, -0.05637725, -0.04986635, -0.0359582 , -0.0165312 ,\n       -0.0037266 , -0.00854037, -0.01722933, -0.02808069, -0.03890767,\n       -0.04743369, -0.05169392, -0.05038455, -0.04309953, -0.03041447,\n       -0.01382252, -0.00310381, -0.00688309, -0.01381975, -0.022762  ,\n       -0.03219883, -0.04048418, -0.04608193, -0.04779579, -0.04495038,\n       -0.03749714, -0.02603018, -0.01172626])"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_LARGEX_RT", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_LARGEX_RT", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([ 0.5       ,  0.27525513,  2.72474487,  0.19016351,  1.78449275,\n        5.52534374,  0.14530352,  1.33909729,  3.9269635 ,  8.58863569,\n        0.11758132,  1.07456201,  3.08593744,  6.41472973, 11.80718949,\n        0.09874701,  0.89830283,  2.5525898 ,  5.19615253,  9.12424804,\n       15.12995978,  0.08511544,  0.77213792,  2.18059189,  4.38979289,\n        7.55409133, 11.98999304, 18.5282775 ,  0.07479188,  0.67724909,\n        1.90511364,  3.80947636,  6.48314543, 10.09332368, 14.97262709,\n       21.98427284,  0.06670223,  0.60323636,  1.69239508,  3.36917627,\n        5.69442334,  8.76975673, 12.77182535, 18.04650547, 25.48597917,\n        0.06019206,  0.5438675 ,  1.52294411,  3.02251338,  5.08490775,\n        7.77743923, 11.2081302 , 15.56116333, 21.1938921 , 29.02495034,\n        0.05483987,  0.49517412,  1.38465574,  2.74191994,  4.5977377 ,\n        6.99939747, 10.01890828, 13.76930587, 18.44111968, 24.40196124,\n       32.59498009,  0.05036189,  0.45450668,  1.26958994,  2.5098481 ,\n        4.19841564,  6.36997539,  9.07543423, 12.39044796, 16.43219509,\n       21.39675594, 27.66110878, 36.19136036])"}, {"fullname": "pyfock.Integrals.rys_helpers.POLY_LARGEX_WW", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "POLY_LARGEX_WW", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([1.00000000e+00, 9.08248290e-01, 9.17517095e-02, 8.17656939e-01,\n       1.77231492e-01, 5.11156880e-03, 7.46024515e-01, 2.34479815e-01,\n       1.92704402e-02, 2.25229077e-04, 6.89284670e-01, 2.70967406e-01,\n       3.82231610e-02, 1.51614187e-03, 8.62130526e-06, 6.43328723e-01,\n       2.93934096e-01, 5.82333758e-02, 4.40676138e-03, 9.67436985e-05,\n       2.99985434e-07, 6.05269254e-01, 3.08166680e-01, 7.73002176e-02,\n       8.85783821e-03, 4.00679108e-04, 5.32198269e-06, 9.73632252e-09,\n       5.73137042e-01, 3.16676746e-01, 9.45695047e-02, 1.45338752e-02,\n       1.05196985e-03, 3.06000643e-05, 2.61894643e-07, 2.99562945e-10,\n       5.45566469e-01, 3.21370608e-01, 1.09793265e-01, 2.10330355e-02,\n       2.13096959e-03, 1.03597923e-04, 2.04310480e-06, 1.18109770e-08,\n       8.83317754e-12, 5.21586127e-01, 3.23478668e-01, 1.23012744e-01,\n       2.79956749e-02, 3.66020626e-03, 2.57652560e-04, 8.80424218e-06,\n       1.22549805e-07, 4.96412472e-10, 2.51560134e-13, 5.00487193e-01,\n       3.23812587e-01, 1.34392623e-01, 3.51381458e-02, 5.61752210e-03,\n       5.24566607e-04, 2.66919543e-05, 6.63970750e-07, 6.73302832e-09,\n       1.96827580e-11, 6.95892130e-15, 4.81740231e-01, 3.22919026e-01,\n       1.44138728e-01, 4.22526888e-02, 7.95321786e-03, 9.29437438e-04,\n       6.41900113e-05, 2.43531949e-06, 4.53492335e-08, 3.43732986e-10,\n       7.42994831e-13, 1.87803874e-16])"}, {"fullname": "pyfock.Integrals.rys_helpers.DATA_X", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "DATA_X", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([ 2.89997627e-02, -1.38283203e-03,  4.90123491e-05, ...,\n       -5.01977554e-21,  7.27919737e-23, -1.05533701e-24])"}, {"fullname": "pyfock.Integrals.rys_helpers.DATA_W", "modulename": "pyfock.Integrals.rys_helpers", "qualname": "DATA_W", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([ 4.68191818e-01, -1.45170049e-02,  5.14736743e-04, ...,\n       -9.47440474e-37,  9.27730349e-39, -9.16732805e-41])"}, {"fullname": "pyfock.Integrals.rys_nuc_mat_symm", "modulename": "pyfock.Integrals.rys_nuc_mat_symm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.rys_nuc_mat_symm.rys_nuc_mat_symm", "modulename": "pyfock.Integrals.rys_nuc_mat_symm", "qualname": "rys_nuc_mat_symm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.rys_nuc_mat_symm.rys_nuc_symm_internal", "modulename": "pyfock.Integrals.rys_nuc_mat_symm", "qualname": "rys_nuc_symm_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">coordsBohrs</span>,</span><span class=\"param\">\t<span class=\"n\">natoms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers", "modulename": "pyfock.Integrals.schwarz_helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.schwarz_helpers.eri_4c2e_diag", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "eri_4c2e_diag", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.parallel_options", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "parallel_options", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;comprehension&#x27;: False, &#x27;prange&#x27;: True, &#x27;numpy&#x27;: True, &#x27;reduction&#x27;: False, &#x27;setitem&#x27;: True, &#x27;stencil&#x27;: True, &#x27;fusion&#x27;: True}"}, {"fullname": "pyfock.Integrals.schwarz_helpers.eri_4c2e_diag_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "eri_4c2e_diag_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_eri_4c2e_diag_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_eri_4c2e_diag_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eri_4c2e_diag</span>, </span><span class=\"param\"><span class=\"n\">ints2c2e</span>, </span><span class=\"param\"><span class=\"n\">nao</span>, </span><span class=\"param\"><span class=\"n\">naux</span>, </span><span class=\"param\"><span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz2", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz_fine", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz_fine", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_offsets_3c2e_schwarz", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_offsets_3c2e_schwarz", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span>,</span><span class=\"param\">\t<span class=\"n\">ntri</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">tril_indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">tril_indicesB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz3", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz3", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_count_3c2e_schwarz", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_count_3c2e_schwarz", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sqrt_ints4c2e_diag</span>, </span><span class=\"param\"><span class=\"n\">sqrt_diag_ints2c2e</span>, </span><span class=\"param\"><span class=\"n\">nao</span>, </span><span class=\"param\"><span class=\"n\">naux</span>, </span><span class=\"param\"><span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_4c2e_schwarz", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_4c2e_schwarz", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">lstart</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz2_test", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz2_test", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eri_4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.calc_indices_3c2e_schwarz_shells", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "calc_indices_3c2e_schwarz_shells", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eri_4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">istart</span>,</span><span class=\"param\">\t<span class=\"n\">jstart</span>,</span><span class=\"param\">\t<span class=\"n\">kstart</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo10", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo10", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">nsignificant</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse2", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">ncores</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo8", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo8", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"n\">ntriplets</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo9", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo9", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">auxbasis</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">IJsq_arr</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo10_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo10_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">IJsq_arr</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">nsignificant</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_internal_old", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_internal_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">IJsq_arr</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_internal2", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_internal2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">IJsq_arr</span>,</span><span class=\"param\">\t<span class=\"n\">ntriplets</span>,</span><span class=\"param\">\t<span class=\"n\">threeC2E</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo9_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo9_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">IJsq_arr</span>,</span><span class=\"param\">\t<span class=\"n\">shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.parallel_options_algo8", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "parallel_options_algo8", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;comprehension&#x27;: False, &#x27;prange&#x27;: False, &#x27;numpy&#x27;: False, &#x27;reduction&#x27;: False, &#x27;setitem&#x27;: False, &#x27;stencil&#x27;: False, &#x27;fusion&#x27;: False}"}, {"fullname": "pyfock.Integrals.schwarz_helpers.rys_3c2e_tri_schwarz_sparse_algo8_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "rys_3c2e_tri_schwarz_sparse_algo8_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">ntriplets</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_test", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_test", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">dmat_1d</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">dmat_1d</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">naux</span>, </span><span class=\"param\"><span class=\"n\">ncores</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">dmat_1d</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_old", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">dmat_1d</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_algo8", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_algo8", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_algo10_serial", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_algo10_serial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_algo10_parallel", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_algo10_parallel", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">ncores</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.df_coeff_calculator_algo10_parallel_internal", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "df_coeff_calculator_algo10_parallel_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">df_coeff</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">size_J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator_algo10", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator_algo10", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">df_coeff</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">size_J_tri</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator_algo8", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator_algo8", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">df_coeff</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">size_J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator_from_4c2e", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator_from_4c2e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints4c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">indicesC</span>,</span><span class=\"param\">\t<span class=\"n\">indicesD</span>,</span><span class=\"param\">\t<span class=\"n\">size_J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator_kernel", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator_kernel", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">df_coeff</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers.J_tri_calculator_cupy", "modulename": "pyfock.Integrals.schwarz_helpers", "qualname": "J_tri_calculator_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ints3c2e_1d</span>, </span><span class=\"param\"><span class=\"n\">df_coeff</span>, </span><span class=\"param\"><span class=\"n\">indicesA</span>, </span><span class=\"param\"><span class=\"n\">indicesB</span>, </span><span class=\"param\"><span class=\"n\">indicesC</span>, </span><span class=\"param\"><span class=\"n\">size_J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.eri_4c2e_diag_cupy", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "eri_4c2e_diag_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">basis</span>, </span><span class=\"param\"><span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.rys_eri_4c2e_diag_internal_cuda", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "rys_eri_4c2e_diag_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.rys_3c2e_tri_schwarz_sparse_algo10_cupy", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "rys_3c2e_tri_schwarz_sparse_algo10_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">basis</span>,</span><span class=\"param\">\t<span class=\"n\">auxbasis</span>,</span><span class=\"param\">\t<span class=\"n\">indicesA</span>,</span><span class=\"param\">\t<span class=\"n\">indicesB</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">nsignificant</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.rys_3c2e_tri_schwarz_sparse_algo10_internal_cuda", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "rys_3c2e_tri_schwarz_sparse_algo10_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.rys_3c2e_tri_schwarz_sparse_algo10_internal_cuda_new", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "rys_3c2e_tri_schwarz_sparse_algo10_internal_cuda_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coords</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_contr_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_lmn</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_nprim</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_coeffs</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_prim_norms</span>,</span><span class=\"param\">\t<span class=\"n\">aux_bfs_expnts</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endA</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endB</span>,</span><span class=\"param\">\t<span class=\"n\">indx_startC</span>,</span><span class=\"param\">\t<span class=\"n\">indx_endC</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_X</span>,</span><span class=\"param\">\t<span class=\"n\">DATA_W</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">schwarz_threshold</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">aux_shell_indices</span>,</span><span class=\"param\">\t<span class=\"n\">out</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.J_tri_calculator_algo10_cupy", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "J_tri_calculator_algo10_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">df_coeff</span>,</span><span class=\"param\">\t<span class=\"n\">size_J_tri</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">auxbfs_lm</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.J_tri_calculator_algo10_internal_cuda", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "J_tri_calculator_algo10_internal_cuda", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">df_coeff</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">J_tri</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.df_coeff_calculator_algo10_cupy", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "df_coeff_calculator_algo10_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">cp_stream</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.df_coeff_calculator_algo10_cuda_internal", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "df_coeff_calculator_algo10_cuda_internal", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ints3c2e_1d</span>,</span><span class=\"param\">\t<span class=\"n\">dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">nao</span>,</span><span class=\"param\">\t<span class=\"n\">size_dmat_1d</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_3c2e</span>,</span><span class=\"param\">\t<span class=\"n\">naux</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_ints4c2e_diag</span>,</span><span class=\"param\">\t<span class=\"n\">sqrt_diag_ints2c2e</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span>,</span><span class=\"param\">\t<span class=\"n\">strict_schwarz</span>,</span><span class=\"param\">\t<span class=\"n\">df_coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Integrals.schwarz_helpers_cupy.fuse", "modulename": "pyfock.Integrals.schwarz_helpers_cupy", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol", "modulename": "pyfock.Mol", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Mol.Mol", "modulename": "pyfock.Mol", "qualname": "Mol", "kind": "class", "doc": "<p>Class to store molecular properties and handle molecular structure operations.</p>\n\n<p>This class provides functionality for creating, manipulating, and exporting molecular\nstructures. It supports reading from various coordinate file formats and automatically\ngenerates basis set information.</p>\n\n<p>Attributes:\n    coordfile (str): Path to coordinate file\n    atoms (list): List of atoms with coordinates\n    charge (int): Molecular charge\n    basis (Basis): Basis set object for the molecule\n    nelectrons (int): Number of electrons\n    natoms (int): Number of atoms\n    coords (numpy.ndarray): Atomic coordinates in Angstroms\n    coordsBohrs (numpy.ndarray): Atomic coordinates in Bohr units\n    atomicSpecies (list): List of atomic symbols\n    Zcharges (list): List of atomic numbers\n    success (bool): Whether molecule was initialized successfully\n    label (str): Molecular label/description</p>\n"}, {"fullname": "pyfock.Mol.Mol.__init__", "modulename": "pyfock.Mol", "qualname": "Mol.__init__", "kind": "function", "doc": "<p>Initialize a Mol object with atomic coordinates and properties.</p>\n\n<p>Args:\n    atoms (list, optional): List of atoms in the format [[symbol, x, y, z], ...] \n                           where symbol can be atomic symbol (str) or atomic number (int),\n                           and x, y, z are coordinates in Angstroms.\n    coordfile (str, optional): Path to coordinate file (.xyz format supported).\n    charge (int, optional): Molecular charge. Defaults to 0.\n    basis (dict, optional): Basis set specification. If None, defaults to STO-3G \n                           for all atoms.</p>\n\n<p>Raises:\n    ValueError: If neither atoms nor coordfile is provided.\n    TypeError: If coordfile is not a string.</p>\n\n<p>Note:\n    If both atoms and coordfile are provided, atoms takes precedence and \n    coordfile is ignored.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">atoms</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">coordfile</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">charge</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">basis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyfock.Mol.Mol.coordfile", "modulename": "pyfock.Mol", "qualname": "Mol.coordfile", "kind": "variable", "doc": "<p>str or None: Path to the coordinate file used to initialize the molecule.\nContains the filename of the original coordinate file (.xyz, .mol, TURBOMOLE coord, etc.) \nif the molecule was created from a file, or None if created directly from atoms list.</p>\n"}, {"fullname": "pyfock.Mol.Mol.atoms", "modulename": "pyfock.Mol", "qualname": "Mol.atoms", "kind": "variable", "doc": "<p>list: List of atoms with their coordinates in the format [[symbol, x, y, z], ...] where:</p>\n\n<ul>\n<li>symbol: Atomic symbol (str) or atomic number (int)</li>\n<li>x, y, z: Cartesian coordinates in Angstroms (float)\nThis is the raw input data used to construct the molecule.</li>\n</ul>\n"}, {"fullname": "pyfock.Mol.Mol.charge", "modulename": "pyfock.Mol", "qualname": "Mol.charge", "kind": "variable", "doc": "<p>int: Net charge of the molecule in elementary charge units.\nPositive values indicate cationic species, negative values indicate anionic species, \nand 0 indicates a neutral molecule. Used to calculate the total number of electrons.</p>\n"}, {"fullname": "pyfock.Mol.Mol.basis", "modulename": "pyfock.Mol", "qualname": "Mol.basis", "kind": "variable", "doc": "<p>Basis or None: Basis set object containing all basis function information for quantum \nchemical calculations. Initialized as None and populated with a Basis instance that \nhandles basis set assignments for each atom in the molecule.</p>\n"}, {"fullname": "pyfock.Mol.Mol.nelectrons", "modulename": "pyfock.Mol", "qualname": "Mol.nelectrons", "kind": "variable", "doc": "<p>int: Total number of electrons in the molecule.\nCalculated as the sum of all atomic numbers (nuclear charges) adjusted by the molecular charge:\nnelectrons = \u03a3(Z_i) - charge, where Z_i is the atomic number of atom i.</p>\n"}, {"fullname": "pyfock.Mol.Mol.natoms", "modulename": "pyfock.Mol", "qualname": "Mol.natoms", "kind": "variable", "doc": "<p>int: Total number of atoms in the molecule.\nIncremented during atom validation and used for array dimensioning and iteration \nover atomic properties.</p>\n"}, {"fullname": "pyfock.Mol.Mol.coords", "modulename": "pyfock.Mol", "qualname": "Mol.coords", "kind": "variable", "doc": "<p>numpy.ndarray: Atomic coordinates in Angstroms with shape (natoms, 3).\nEach row contains the [x, y, z] coordinates of one atom. Initialized as empty list \nand populated during atom validation to become a numpy array.</p>\n"}, {"fullname": "pyfock.Mol.Mol.coordsBohrs", "modulename": "pyfock.Mol", "qualname": "Mol.coordsBohrs", "kind": "variable", "doc": "<p>numpy.ndarray: Atomic coordinates converted to Bohr units with shape (natoms, 3).\nCalculated from self.coords using the conversion factor Data.Angs2BohrFactor. \nUsed for quantum chemical calculations requiring atomic units of length.</p>\n"}, {"fullname": "pyfock.Mol.Mol.atomicSpecies", "modulename": "pyfock.Mol", "qualname": "Mol.atomicSpecies", "kind": "variable", "doc": "<p>list of str: List of atomic symbols as strings (e.g., ['H', 'C', 'N', 'O']).\nOrdered the same as atoms appear in the molecule. Length equals natoms. \nUsed for identifying atom types and output formatting.</p>\n"}, {"fullname": "pyfock.Mol.Mol.Zcharges", "modulename": "pyfock.Mol", "qualname": "Mol.Zcharges", "kind": "variable", "doc": "<p>list of int: List of atomic numbers (nuclear charges) for each atom in the molecule.\nCorresponds to the number of protons in each atomic nucleus. Used for calculating \nelectronic properties and nuclear contributions to various molecular properties.</p>\n"}, {"fullname": "pyfock.Mol.Mol.success", "modulename": "pyfock.Mol", "qualname": "Mol.success", "kind": "variable", "doc": "<p>bool: Flag indicating whether the molecule was successfully initialized and validated.\nSet to True if all atoms have valid symbols/atomic numbers and properly formatted \ncoordinates, False otherwise. Used to prevent operations on invalid molecular data.</p>\n"}, {"fullname": "pyfock.Mol.Mol.label", "modulename": "pyfock.Mol", "qualname": "Mol.label", "kind": "variable", "doc": "<p>str: Descriptive label or name for the molecule.\nDefaults to 'Generic mol' but can be customized. Used in output files and for \nidentification purposes when exporting molecular data to various file formats.</p>\n"}, {"fullname": "pyfock.Mol.Mol.validateAtoms", "modulename": "pyfock.Mol", "qualname": "Mol.validateAtoms", "kind": "function", "doc": "<p>Validate atomic symbols and coordinates provided in the atoms list.</p>\n\n<p>This method checks that atomic symbols are valid (either as strings matching\nknown element symbols or as integers representing atomic numbers), and that\ncoordinates are properly formatted as numerical values.</p>\n\n<p>Args:\n    atoms (list): List of atoms in format [[symbol, x, y, z], ...] where\n                 symbol can be str (element symbol) or int (atomic number),\n                 and x, y, z are numerical coordinates.</p>\n\n<p>Returns:\n    bool: True if all atoms are valid, False otherwise.</p>\n\n<p>Side Effects:\n    Updates the following instance attributes:\n    - atomicSpecies: List of atomic symbols\n    - Zcharges: List of atomic numbers\n    - nelectrons: Total number of electrons\n    - natoms: Number of atoms\n    - coords: Numpy array of coordinates</p>\n\n<p>Raises:\n    Prints error messages for invalid atomic symbols, coordinates, or formatting.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">atoms</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.get_center_of_charge", "modulename": "pyfock.Mol", "qualname": "Mol.get_center_of_charge", "kind": "function", "doc": "<p>Calculate the center of charge (weighted by atomic numbers) of the molecule.</p>\n\n<p>The center of charge is computed as the weighted average of atomic positions,\nwhere the weights are the atomic numbers (nuclear charges) of each atom.</p>\n\n<p>Returns:\n    numpy.ndarray or None: 3D coordinates of the center of charge in Angstroms.\n                          Returns None if the molecule was not successfully initialized.</p>\n\n<p>Formula:\n    center_of_charge = \u03a3(Z_i * r_i) / \u03a3(Z_i)\n    where Z_i is the atomic number and r_i is the position of atom i.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.get_nuc_dip_moment", "modulename": "pyfock.Mol", "qualname": "Mol.get_nuc_dip_moment", "kind": "function", "doc": "<p>Calculate the nuclear contribution to the molecular dipole moment.</p>\n\n<p>The nuclear dipole moment is computed as the sum of nuclear charges\nmultiplied by their positions in atomic units (Bohr).</p>\n\n<p>Returns:\n    numpy.ndarray: 3D vector representing the nuclear dipole moment\n                  in atomic units (e\u22c5a\u2080), where each component corresponds\n                  to x, y, z directions.</p>\n\n<p>Formula:\n    \u03bc_nuc = \u03a3(Z_i * r_i)\n    where Z_i is the nuclear charge and r_i is the position in Bohr units.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.get_elec_dip_moment", "modulename": "pyfock.Mol", "qualname": "Mol.get_elec_dip_moment", "kind": "function", "doc": "<p>Calculate the electronic contribution to the molecular dipole moment.</p>\n\n<p>The electronic dipole moment is computed using the dipole moment integrals\nand the density matrix from quantum chemical calculations.</p>\n\n<p>Args:\n    dipole_moment_matrix (numpy.ndarray): 3D array of dipole moment integrals\n                                         with shape (3, nbasis, nbasis), where\n                                         the first dimension corresponds to x, y, z.\n    dmat (numpy.ndarray): Density matrix with shape (nbasis, nbasis).</p>\n\n<p>Returns:\n    numpy.ndarray: 3D vector representing the electronic dipole moment\n                  in atomic units (e\u22c5a\u2080), where each component corresponds\n                  to x, y, z directions.</p>\n\n<p>Formula:\n    \u03bc_elec = \u03a3_\u03bc\u03bd P_\u03bc\u03bd \u27e8\u03bc|r|\u03bd\u27e9\n    where P_\u03bc\u03bd is the density matrix and \u27e8\u03bc|r|\u03bd\u27e9 are dipole integrals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dipole_moment_matrix</span>, </span><span class=\"param\"><span class=\"n\">dmat</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.get_dipole_moment", "modulename": "pyfock.Mol", "qualname": "Mol.get_dipole_moment", "kind": "function", "doc": "<p>Calculate the total molecular dipole moment.</p>\n\n<p>The total dipole moment is computed as the difference between nuclear\nand electronic contributions: \u03bc_total = \u03bc_nuclear - \u03bc_electronic</p>\n\n<p>Args:\n    dipole_moment_matrix (numpy.ndarray): 3D array of dipole moment integrals\n                                         with shape (3, nbasis, nbasis).\n    dmat (numpy.ndarray): Density matrix from quantum chemical calculation\n                         with shape (nbasis, nbasis).</p>\n\n<p>Returns:\n    numpy.ndarray: 3D vector representing the total molecular dipole moment\n                  in atomic units (e\u22c5a\u2080). Each component corresponds to\n                  x, y, z directions.</p>\n\n<p>Note:\n    The sign convention follows: \u03bc_total = \u03bc_nuclear - \u03bc_electronic\n    This gives the dipole moment vector pointing from negative to positive charge.</p>\n\n<p>TODO: Allow user to specify output units (e.g., Debye).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dipole_moment_matrix</span>, </span><span class=\"param\"><span class=\"n\">dmat</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.exportCoords", "modulename": "pyfock.Mol", "qualname": "Mol.exportCoords", "kind": "function", "doc": "<p>Export molecular coordinates to TURBOMOLE format.</p>\n\n<p>Creates a coordinate file in TURBOMOLE format with atomic positions\nconverted from Angstroms to Bohr units.</p>\n\n<p>Args:\n    atomicSpecies (list): List of atomic symbols as strings.\n    coords (numpy.ndarray): Atomic coordinates in Angstroms with shape (natoms, 3).\n    filename (str, optional): Output filename. Defaults to 'coord'.</p>\n\n<p>File Format:\n    $coord\n    x_bohr y_bohr z_bohr element_symbol\n    ...\n    $end</p>\n\n<p>Note:\n    This is a static method that should be called as a class method.\n    Coordinates are automatically converted from Angstroms to Bohr units.</p>\n\n<p>Warning:\n    This method contains a bug - it references undefined variable 'coord'\n    instead of 'coords'. Should be fixed in implementation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">atomicSpecies</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;coord&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.exportXYZ", "modulename": "pyfock.Mol", "qualname": "Mol.exportXYZ", "kind": "function", "doc": "<p>Export molecular geometry to XYZ format file.</p>\n\n<p>Creates a standard XYZ format file with atomic coordinates in Angstroms.\nThis method uses the molecule's current atomic species and coordinates.</p>\n\n<p>Args:\n    filename (str, optional): Base filename without extension. Defaults to 'coord'.\n                             The '.xyz' extension will be automatically added.\n    label (str, optional): Comment line for the XYZ file. Defaults to \n                          'Generic Mol generated by CrysX (Python Library)'.</p>\n\n<p>File Format:\n    number_of_atoms\n    comment_line\n    element_symbol x_coord y_coord z_coord\n    ...</p>\n\n<p>Output:\n    Creates a file named '{filename}.xyz' in the current directory.</p>\n\n<p>Example:\n    mol.exportXYZ('water', 'H2O molecule')\n    # Creates 'water.xyz' with H2O coordinates</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;coord&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;Generic Mol generated by CrysX (Python Library)&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.exportXYZs", "modulename": "pyfock.Mol", "qualname": "Mol.exportXYZs", "kind": "function", "doc": "<p>Export molecular geometry to XYZ format (static method version).</p>\n\n<p>Static method to create XYZ files from provided atomic species and coordinates,\nwithout requiring a Mol object instance.</p>\n\n<p>Args:\n    atomicSpecies (list): List of atomic symbols as strings.\n    coords (numpy.ndarray): Atomic coordinates in Angstroms with shape (natoms, 3).\n    filename (str, optional): Base filename without extension. Defaults to 'coord'.\n                             The '.xyz' extension will be automatically added.\n    label (str, optional): Comment line for the XYZ file. Defaults to \n                          'Generic Mol generated by CrysX (Python Library)'.</p>\n\n<p>File Format:\n    number_of_atoms\n    comment_line\n    element_symbol x_coord y_coord z_coord\n    ...</p>\n\n<p>Warning:\n    This method contains a bug - it references undefined variable 'coord'\n    instead of 'coords'. Should be fixed in implementation.</p>\n\n<p>Note:\n    This is a static method and should be called as a class method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">atomicSpecies</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;coord&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;Generic Mol generated by CrysX (Python Library)&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.readCoordsFile", "modulename": "pyfock.Mol", "qualname": "Mol.readCoordsFile", "kind": "function", "doc": "<p>Read molecular coordinates from various file formats.</p>\n\n<p>Currently supports XYZ format files. This method serves as a dispatcher\nto format-specific reading methods based on file extension.</p>\n\n<p>Args:\n    filename (str): Path to the coordinate file. File format is determined\n                   by the file extension.</p>\n\n<p>Returns:\n    list: List of atoms in the format [[symbol, x, y, z], ...] where\n          symbol is the atomic symbol and x, y, z are coordinates in Angstroms.</p>\n\n<p>Supported Formats:\n    - .xyz: Standard XYZ coordinate format</p>\n\n<p>Future Extensions:\n    - .mol: MOL file format\n    - coord: TURBOMOLE coordinate format\n    - Other quantum chemistry input formats</p>\n\n<p>Raises:\n    Prints error message if file format is not supported.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Mol.Mol.readXYZ", "modulename": "pyfock.Mol", "qualname": "Mol.readXYZ", "kind": "function", "doc": "<p>Read molecular geometry from an XYZ format file.</p>\n\n<p>Parses a standard XYZ file and extracts atomic symbols and coordinates.\nThe XYZ format consists of:</p>\n\n<ul>\n<li>Line 1: Number of atoms</li>\n<li>Line 2: Comment line (ignored)</li>\n<li>Lines 3+: atomic_symbol x_coordinate y_coordinate z_coordinate</li>\n</ul>\n\n<p>Args:\n    filename (str): Path to the XYZ file to read.</p>\n\n<p>Returns:\n    list: List of atoms in format [[symbol, x, y, z], ...] where:\n          - symbol (str): Atomic symbol (e.g., 'H', 'C', 'O')\n          - x, y, z (float): Coordinates in Angstroms</p>\n\n<p>File Format Expected:\n    number_of_atoms\n    comment_line\n    element_symbol x_coord y_coord z_coord\n    element_symbol x_coord y_coord z_coord\n    ...</p>\n\n<p>Error Handling:\n    - Prints error if the number of atoms read doesn't match the declared count\n    - Assumes coordinates are separated by whitespace\n    - Strips whitespace from all input</p>\n\n<p>Example:\n    For a file 'water.xyz':\n    3\n    Water molecule\n    O    0.000000    0.000000    0.000000\n    H    0.000000    0.000000    0.970000\n    H    0.944863    0.000000   -0.242498</p>\n\n<pre><code>Returns: [['O', 0.0, 0.0, 0.0], ['H', 0.0, 0.0, 0.97], ['H', 0.944863, 0.0, -0.242498]]\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Utils", "modulename": "pyfock.Utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.Utils.print_sys_info", "modulename": "pyfock.Utils", "qualname": "print_sys_info", "kind": "function", "doc": "<p>Print comprehensive system information to stdout.</p>\n\n<p>Displays detailed system specifications including:</p>\n\n<ul>\n<li>Operating system name and version</li>\n<li>System architecture (32-bit/64-bit)</li>\n<li>CPU model and specifications</li>\n<li>Number of physical CPU cores</li>\n<li>Number of logical CPU threads</li>\n<li>Total system memory in gigabytes</li>\n</ul>\n\n<p>The information is formatted in a human-readable format with\nlabeled key-value pairs.</p>\n\n<p>Returns:\n    None: This function only prints to stdout and returns nothing.</p>\n\n<p>Examples:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>from pyfock import Utils\n      Utils.print_sys_info()\n          Operating System: Linux 5.15.0\n          System Type: 64bit\n          CPU Model: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\n          Number of Cores: 6\n          Number of Threads: 12\n          Memory (GB): 15.54</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    Some information may show as \"Unavailable\" if the system\n    doesn't provide access to certain hardware details.</p>\n\n<p>Dependencies:\n    Requires psutil, platform modules and the get_cpu_model() function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Utils.get_cpu_model", "modulename": "pyfock.Utils", "qualname": "get_cpu_model", "kind": "function", "doc": "<p>Return CPU model information in a cross-platform manner.</p>\n\n<p>Retrieves the CPU model string using platform-specific methods:</p>\n\n<ul>\n<li>Windows: Uses platform.processor()</li>\n<li>macOS: Executes sysctl command to get brand string</li>\n<li>Linux: Reads from /proc/cpuinfo</li>\n<li>Other: Returns \"Unknown CPU\"</li>\n</ul>\n\n<p>Returns:\n    str: The CPU model name/description, or an error message if retrieval fails.</p>\n\n<p>Examples:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>cpu_model = get_cpu_model()\n      print(cpu_model)\n          Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    On some systems, CPU model information may not be available or\n    may require elevated privileges to access.</p>\n\n<p>Raises:\n    No exceptions are raised directly, but any underlying system errors\n    are caught and returned as descriptive error messages.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.Utils.print_pyfock_logo", "modulename": "pyfock.Utils", "qualname": "print_pyfock_logo", "kind": "function", "doc": "<p>Print PyFock logo with gradient colors using ANSI escape codes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC", "modulename": "pyfock.XC", "kind": "module", "doc": "<p>This module provides a collection of exchange-correlation (XC) functionals \ncommonly used in density functional theory (DFT) calculations. It includes \nboth exchange-only (X) and correlation (C) functionals within the LDA and GGA \nframeworks, along with their respective CuPy-accelerated implementations \nfor GPU computation.</p>\n\n<p>Available functionals:</p>\n\n<ul>\n<li>LDA exchange and correlation (X: lda_x, C: lda_c_vwn, lda_c_pw, lda_c_pw_mod)</li>\n<li>GGA exchange and correlation (X: gga_x_pbe, gga_x_b88; C: gga_c_pbe, gga_c_lyp)</li>\n<li>CuPy variants for GPU-accelerated computation (e.g., lda_x_cupy, gga_c_pbe_cupy)</li>\n</ul>\n\n<p>Also includes utility functions:</p>\n\n<ul>\n<li><code>check_implemented</code>: verifies if a given XC functional is implemented.</li>\n<li><code>func_compute</code>: generic interface to compute XC energy and potential.</li>\n</ul>\n\n<p>All components can be imported directly from this module.</p>\n"}, {"fullname": "pyfock.XC.lda_x", "modulename": "pyfock.XC", "qualname": "lda_x", "kind": "function", "doc": "<p>Compute the LDA exchange energy and potential using the Slater exchange functional (spin-unpolarized).</p>\n\n<p>This is the standard Local Density Approximation (LDA) exchange functional corresponding to \n<code>LDA_X</code> with ID 1 in the LibXC functional library.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (assumed to be spin-paired / spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : ndarray\n    Exchange energy density at each point.</p>\n\n<p>vx : ndarray\n    Exchange potential (functional derivative of exchange energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This implementation is based on:\n    - Phys. Rev. 81, 385 (1951) \u2014 the original Slater exchange.\nCode adapted from the <code>eminus</code> repository:\n    <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\n    Licensed under the Apache License, Version 2.0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_x_cupy", "modulename": "pyfock.XC", "qualname": "lda_x_cupy", "kind": "function", "doc": "<p>GPU-accelerated version of the LDA exchange functional using CuPy.</p>\n\n<p>This is the same as <code>lda_x</code> but leverages CuPy for GPU computation. It corresponds to \n<code>LDA_X</code> with ID 1 in LibXC for spin-unpolarized electron density.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array (spin-unpolarized), on GPU.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : cupy.ndarray\n    Exchange energy density at each point.</p>\n\n<p>vx : cupy.ndarray\n    Exchange potential (functional derivative of exchange energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Based on the Slater exchange:\n    - Phys. Rev. 81, 385 (1951)\nAdapted from: <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<p>This version is fused using CuPy's <code>@fuse</code> decorator for better performance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn", "modulename": "pyfock.XC", "qualname": "lda_c_vwn", "kind": "function", "doc": "<p>Wrapper function for <code>lda_c_vwn_</code> providing the LDA correlation energy and potential using VWN parametrization.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density.</p>\n\n<p>vc : ndarray\n    Correlation potential.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is equivalent to <code>lda_c_vwn_</code> but kept as a public-facing interface in PyFock.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn_cupy", "modulename": "pyfock.XC", "qualname": "lda_c_vwn_cupy", "kind": "function", "doc": "<p>Safe wrapper for the GPU-based VWN LDA correlation functional.</p>\n\n<p>This function calls <code>lda_c_vwn_cupy_</code>, and replaces any NaNs in the result with zeros \nto ensure numerical stability in downstream calculations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array on GPU.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is a numerically safe version of <code>lda_c_vwn_cupy_</code> intended for production use.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw", "modulename": "pyfock.XC", "qualname": "lda_c_pw", "kind": "function", "doc": "<p>Numerically stable wrapper for the Perdew-Wang (PW92) LDA correlation functional.</p>\n\n<p>This calls <code>lda_c_pw_</code>, then replaces any NaNs in the result with zeros to ensure \ndownstream stability in SCF or post-processing steps.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (non-negative, spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is the CPU-based version. Use <code>lda_c_pw_cupy</code> for GPU acceleration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_cupy", "modulename": "pyfock.XC", "qualname": "lda_c_pw_cupy", "kind": "function", "doc": "<p>Numerically stable GPU wrapper for the Perdew-Wang LDA correlation functional.</p>\n\n<p>This function calls <code>lda_c_pw_cupy_</code> and replaces any NaNs in the resulting arrays\nwith zeros to ensure stability during molecular dynamics or SCF procedures.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array on GPU (non-negative, spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Use this function for production GPU workflows where numerical robustness is critical.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod", "modulename": "pyfock.XC", "qualname": "lda_c_pw_mod", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod_cupy", "modulename": "pyfock.XC", "qualname": "lda_c_pw_mod_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe", "modulename": "pyfock.XC", "qualname": "gga_x_pbe", "kind": "function", "doc": "<p>Compute the restricted PBE (Perdew\u2013Burke\u2013Ernzerhof) exchange energy density and potential\nusing NumPy arrays for electron density and its gradient.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array.\nsigma : ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : ndarray\n    Exchange energy density.\nvx : ndarray\n    Functional derivative of the exchange energy with respect to density.\nvsigma : ndarray\n    Functional derivative of the exchange energy with respect to the density gradient term \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe_cupy", "modulename": "pyfock.XC", "qualname": "gga_x_pbe_cupy", "kind": "function", "doc": "<p>Compute the restricted PBE exchange energy density and potential\nusing CuPy for GPU acceleration.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cp.ndarray\n    Electron density array (CuPy).\nsigma : cp.ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1 (CuPy).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : cp.ndarray\n    Exchange energy density.\nvx : cp.ndarray\n    Functional derivative of the exchange energy with respect to density.\nvsigma : cp.ndarray\n    Functional derivative of the exchange energy with respect to the density gradient term \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe", "modulename": "pyfock.XC", "qualname": "gga_c_pbe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe_cupy", "modulename": "pyfock.XC", "qualname": "gga_c_pbe_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88", "modulename": "pyfock.XC", "qualname": "gga_x_b88", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88_cupy", "modulename": "pyfock.XC", "qualname": "gga_x_b88_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp", "modulename": "pyfock.XC", "qualname": "gga_c_lyp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp_cupy", "modulename": "pyfock.XC", "qualname": "gga_c_lyp_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.check_implemented", "modulename": "pyfock.XC", "qualname": "check_implemented", "kind": "function", "doc": "<p>Check if the given functional ID is implemented in PyFock.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>funcid : int\n    LibXC-style functional ID (e.g., 1 for LDA_X, 101 for GGA_X_PBE).</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>SystemExit\n    If the functional ID is not supported by PyFock, prints an error and exits.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Implemented functional IDs in PyFock:\n    - 1   : LDA_X\n    - 7   : LDA_C_VWN\n    - 12  : LDA_C_PW\n    - 13  : LDA_C_PW_MOD\n    - 101 : GGA_X_PBE\n    - 106 : GGA_X_B88\n    - 131 : GGA_C_LYP\nFor unsupported functionals, you can use LibXC directly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">funcid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.func_compute", "modulename": "pyfock.XC", "qualname": "func_compute", "kind": "function", "doc": "<p>Compute exchange-correlation energy and potential using the specified functional.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>funcid : int\n    Identifier for the XC functional. Matches LibXC IDs:\n        - 1   : LDA_X\n        - 7   : LDA_C_VWN\n        - 12  : LDA_C_PW\n        - 13  : LDA_C_PW_MOD\n        - 101 : GGA_X_PBE\n        - 106 : GGA_X_B88\n        - 130 : GGA_C_PBE\n        - 131 : GGA_C_LYP</p>\n\n<p>rho : ndarray\n    Electron density array. Should be shape-compatible with the expected input of the XC functional.</p>\n\n<p>sigma : ndarray, optional\n    Gradient of the density (\u2207\u03c1\u00b7\u2207\u03c1), required for GGA functionals.</p>\n\n<p>use_gpu : bool, default=True\n    Whether to use CuPy (GPU) versions of the functionals. If False, falls back to CPU (NumPy) versions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>energy_density : ndarray\n    The exchange-correlation energy density at each grid point.</p>\n\n<p>potential : ndarray or tuple\n    The exchange-correlation potential, and for GGA, possibly its derivative with respect to sigma.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>SystemExit\n    If the functional is not implemented in PyFock.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>For unsupported functionals (i.e., other than those listed above), use LibXC.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">funcid</span>, </span><span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">use_gpu</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp", "modulename": "pyfock.XC.gga_c_lyp", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp_e", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp_e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp_v", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp_v", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp_e_cupy", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp_e_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp_v_cupy", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp_v_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.gga_c_lyp_cupy", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "gga_c_lyp_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_lyp.fuse", "modulename": "pyfock.XC.gga_c_lyp", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe", "modulename": "pyfock.XC.gga_c_pbe", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.gga_c_pbe.gga_c_pbe_cupy_", "modulename": "pyfock.XC.gga_c_pbe", "qualname": "gga_c_pbe_cupy_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe.gga_c_pbe", "modulename": "pyfock.XC.gga_c_pbe", "qualname": "gga_c_pbe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe.gga_c_pbe_cupy", "modulename": "pyfock.XC.gga_c_pbe", "qualname": "gga_c_pbe_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_c_pbe.fuse", "modulename": "pyfock.XC.gga_c_pbe", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88", "modulename": "pyfock.XC.gga_x_b88", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88_e", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88_e", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88_v", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88_v", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88_e_cupy", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88_e_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88_v_cupy", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88_v_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.gga_x_b88_cupy", "modulename": "pyfock.XC.gga_x_b88", "qualname": "gga_x_b88_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_b88.fuse", "modulename": "pyfock.XC.gga_x_b88", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe", "modulename": "pyfock.XC.gga_x_pbe", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.gga_x_pbe.gga_x_pbe", "modulename": "pyfock.XC.gga_x_pbe", "qualname": "gga_x_pbe", "kind": "function", "doc": "<p>Compute the restricted PBE (Perdew\u2013Burke\u2013Ernzerhof) exchange energy density and potential\nusing NumPy arrays for electron density and its gradient.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array.\nsigma : ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : ndarray\n    Exchange energy density.\nvx : ndarray\n    Functional derivative of the exchange energy with respect to density.\nvsigma : ndarray\n    Functional derivative of the exchange energy with respect to the density gradient term \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe.pbe_x_temp", "modulename": "pyfock.XC.gga_x_pbe", "qualname": "pbe_x_temp", "kind": "function", "doc": "<p>Intermediate computation for PBE exchange: enhancement factor, \nexchange potential and derivative with respect to \u03c3.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array.\nsigma : ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>gex : ndarray\n    Gradient correction to the exchange energy density.\ngvx : ndarray\n    Correction to the exchange potential (derivative with respect to density).\nvsigmax : ndarray\n    Derivative of the exchange energy with respect to \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe.pbe_x_temp_cupy", "modulename": "pyfock.XC.gga_x_pbe", "qualname": "pbe_x_temp_cupy", "kind": "function", "doc": "<p>CuPy-accelerated version of <code>pbe_x_temp</code>. Computes the enhancement factor,\nexchange potential, and \u03c3-derivative for the PBE exchange functional.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cp.ndarray\n    Electron density array (CuPy).\nsigma : cp.ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1 (CuPy).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>gex : cp.ndarray\n    Gradient correction to the exchange energy density.\ngvx : cp.ndarray\n    Correction to the exchange potential (derivative with respect to density).\nvsigmax : cp.ndarray\n    Derivative of the exchange energy with respect to \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe.gga_x_pbe_cupy", "modulename": "pyfock.XC.gga_x_pbe", "qualname": "gga_x_pbe_cupy", "kind": "function", "doc": "<p>Compute the restricted PBE exchange energy density and potential\nusing CuPy for GPU acceleration.</p>\n\n<h2 id=\"adapted-from\">Adapted from</h2>\n\n<p>Eminus project:\n<a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/gga_x_pbe.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<h2 id=\"reference\">Reference</h2>\n\n<p>J. P. Perdew, K. Burke, and M. Ernzerhof,\n\"Generalized Gradient Approximation Made Simple\",\nPhys. Rev. Lett. 77, 3865 (1996).\n<a href=\"https://doi.org/10.1103/PhysRevLett.77.3865\">https://doi.org/10.1103/PhysRevLett.77.3865</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cp.ndarray\n    Electron density array (CuPy).\nsigma : cp.ndarray\n    Gradient of the electron density, defined as \u2207\u03c1\u00b7\u2207\u03c1 (CuPy).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : cp.ndarray\n    Exchange energy density.\nvx : cp.ndarray\n    Functional derivative of the exchange energy with respect to density.\nvsigma : cp.ndarray\n    Functional derivative of the exchange energy with respect to the density gradient term \u03c3.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span>, </span><span class=\"param\"><span class=\"n\">sigma</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.gga_x_pbe.fuse", "modulename": "pyfock.XC.gga_x_pbe", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw", "modulename": "pyfock.XC.lda_c_pw", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.lda_c_pw.lda_c_pw_", "modulename": "pyfock.XC.lda_c_pw", "qualname": "lda_c_pw_", "kind": "function", "doc": "<p>Compute the LDA correlation energy and potential using the Perdew-Wang (PW92) parametrization.</p>\n\n<p>This is the spin-unpolarized version of the LDA_C_PW correlation functional (LibXC ID 12).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (assumed to be spin-unpolarized). Should be non-negative.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density at each grid point.</p>\n\n<p>vc : ndarray\n    Correlation potential (functional derivative of correlation energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Reference:\n    - J.P. Perdew and Y. Wang, Phys. Rev. B 45, 13244 (1992).</p>\n\n<p>Implementation adapted from:\n    <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_c_pw.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_c_pw.py</a>\n    Licensed under the Apache License, Version 2.0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw.lda_c_pw", "modulename": "pyfock.XC.lda_c_pw", "qualname": "lda_c_pw", "kind": "function", "doc": "<p>Numerically stable wrapper for the Perdew-Wang (PW92) LDA correlation functional.</p>\n\n<p>This calls <code>lda_c_pw_</code>, then replaces any NaNs in the result with zeros to ensure \ndownstream stability in SCF or post-processing steps.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (non-negative, spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is the CPU-based version. Use <code>lda_c_pw_cupy</code> for GPU acceleration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw.lda_c_pw_cupy_", "modulename": "pyfock.XC.lda_c_pw", "qualname": "lda_c_pw_cupy_", "kind": "function", "doc": "<p>GPU-accelerated implementation of the LDA_C_PW correlation functional using CuPy.</p>\n\n<p>This function computes the Perdew-Wang LDA correlation energy and potential for spin-unpolarized systems.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array on GPU (non-negative, spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density at each grid point.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential (functional derivative of correlation energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Reference:\n    - J.P. Perdew and Y. Wang, Phys. Rev. B 45, 13244 (1992).</p>\n\n<p>Implementation adapted from:\n    <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_c_pw.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_c_pw.py</a>\n    Licensed under the Apache License, Version 2.0.</p>\n\n<p>This version uses CuPy's <code>@fuse</code> decorator to enable kernel fusion for performance optimization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw.lda_c_pw_cupy", "modulename": "pyfock.XC.lda_c_pw", "qualname": "lda_c_pw_cupy", "kind": "function", "doc": "<p>Numerically stable GPU wrapper for the Perdew-Wang LDA correlation functional.</p>\n\n<p>This function calls <code>lda_c_pw_cupy_</code> and replaces any NaNs in the resulting arrays\nwith zeros to ensure stability during molecular dynamics or SCF procedures.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array on GPU (non-negative, spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Use this function for production GPU workflows where numerical robustness is critical.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw.fuse", "modulename": "pyfock.XC.lda_c_pw", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod", "modulename": "pyfock.XC.lda_c_pw_mod", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.lda_c_pw_mod.lda_c_pw_mod_", "modulename": "pyfock.XC.lda_c_pw_mod", "qualname": "lda_c_pw_mod_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod.lda_c_pw_mod", "modulename": "pyfock.XC.lda_c_pw_mod", "qualname": "lda_c_pw_mod", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod.lda_c_pw_mod_cupy_", "modulename": "pyfock.XC.lda_c_pw_mod", "qualname": "lda_c_pw_mod_cupy_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod.lda_c_pw_mod_cupy", "modulename": "pyfock.XC.lda_c_pw_mod", "qualname": "lda_c_pw_mod_cupy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_pw_mod.fuse", "modulename": "pyfock.XC.lda_c_pw_mod", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn", "modulename": "pyfock.XC.lda_c_vwn", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.lda_c_vwn.lda_c_vwn_", "modulename": "pyfock.XC.lda_c_vwn", "qualname": "lda_c_vwn_", "kind": "function", "doc": "<p>Compute the correlation energy and potential using the Vosko-Wilk-Nusair (VWN) LDA correlation functional.</p>\n\n<p>This function implements the spin-unpolarized LDA_C_VWN functional (LibXC ID 7) based on the \nparametrization by Vosko, Wilk, and Nusair.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (assumed to be spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density at each grid point.</p>\n\n<p>vc : ndarray\n    Correlation potential (functional derivative of correlation energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is the raw implementation of the VWN correlation functional adapted from:\n    - Phys. Rev. B 22, 3812 (1980)\nCode source: <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn.lda_c_vwn", "modulename": "pyfock.XC.lda_c_vwn", "qualname": "lda_c_vwn", "kind": "function", "doc": "<p>Wrapper function for <code>lda_c_vwn_</code> providing the LDA correlation energy and potential using VWN parametrization.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : ndarray\n    Correlation energy density.</p>\n\n<p>vc : ndarray\n    Correlation potential.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is equivalent to <code>lda_c_vwn_</code> but kept as a public-facing interface in PyFock.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn.lda_c_vwn_cupy_", "modulename": "pyfock.XC.lda_c_vwn", "qualname": "lda_c_vwn_cupy_", "kind": "function", "doc": "<p>GPU-accelerated implementation of the LDA_C_VWN correlation functional using CuPy.</p>\n\n<p>This is a CuPy version of the Vosko-Wilk-Nusair LDA correlation functional (LibXC ID 7) for spin-unpolarized densities.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array (spin-unpolarized), allocated on GPU.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density at each grid point.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential (functional derivative of correlation energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Based on:\n    - Vosko, Wilk, and Nusair, Phys. Rev. B 22, 3812 (1980)\nAdapted from: <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn.lda_c_vwn_cupy", "modulename": "pyfock.XC.lda_c_vwn", "qualname": "lda_c_vwn_cupy", "kind": "function", "doc": "<p>Safe wrapper for the GPU-based VWN LDA correlation functional.</p>\n\n<p>This function calls <code>lda_c_vwn_cupy_</code>, and replaces any NaNs in the result with zeros \nto ensure numerical stability in downstream calculations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array on GPU.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ec : cupy.ndarray\n    Correlation energy density with NaNs replaced by 0.</p>\n\n<p>vc : cupy.ndarray\n    Correlation potential with NaNs replaced by 0.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is a numerically safe version of <code>lda_c_vwn_cupy_</code> intended for production use.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_c_vwn.fuse", "modulename": "pyfock.XC.lda_c_vwn", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_x", "modulename": "pyfock.XC.lda_x", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyfock.XC.lda_x.lda_x", "modulename": "pyfock.XC.lda_x", "qualname": "lda_x", "kind": "function", "doc": "<p>Compute the LDA exchange energy and potential using the Slater exchange functional (spin-unpolarized).</p>\n\n<p>This is the standard Local Density Approximation (LDA) exchange functional corresponding to \n<code>LDA_X</code> with ID 1 in the LibXC functional library.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : ndarray\n    Electron density array (assumed to be spin-paired / spin-unpolarized).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : ndarray\n    Exchange energy density at each point.</p>\n\n<p>vx : ndarray\n    Exchange potential (functional derivative of exchange energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This implementation is based on:\n    - Phys. Rev. 81, 385 (1951) \u2014 the original Slater exchange.\nCode adapted from the <code>eminus</code> repository:\n    <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\n    Licensed under the Apache License, Version 2.0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_x.lda_x_cupy", "modulename": "pyfock.XC.lda_x", "qualname": "lda_x_cupy", "kind": "function", "doc": "<p>GPU-accelerated version of the LDA exchange functional using CuPy.</p>\n\n<p>This is the same as <code>lda_x</code> but leverages CuPy for GPU computation. It corresponds to \n<code>LDA_X</code> with ID 1 in LibXC for spin-unpolarized electron density.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rho : cupy.ndarray\n    Electron density array (spin-unpolarized), on GPU.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ex : cupy.ndarray\n    Exchange energy density at each point.</p>\n\n<p>vx : cupy.ndarray\n    Exchange potential (functional derivative of exchange energy with respect to density).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Based on the Slater exchange:\n    - Phys. Rev. 81, 385 (1951)\nAdapted from: <a href=\"https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py\">https://github.com/wangenau/eminus/blob/main/eminus/xc/lda_x.py</a>\nLicensed under the Apache License, Version 2.0.</p>\n\n<p>This version is fused using CuPy's <code>@fuse</code> decorator for better performance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rho</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyfock.XC.lda_x.fuse", "modulename": "pyfock.XC.lda_x", "qualname": "fuse", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kernel_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();